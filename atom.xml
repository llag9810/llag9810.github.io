<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌妹子的小窝</title>
  <subtitle>Android学习中/想学算法/游走在挂科边缘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://llag9810.github.io/"/>
  <updated>2017-03-27T06:18:47.000Z</updated>
  <id>http://llag9810.github.io/</id>
  
  <author>
    <name>yifan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stanford Algorithms Divide and Conquer笔记1</title>
    <link href="http://llag9810.github.io/2017/03/26/Stanford-Algorithms-Divide-and-Conquer%E7%AC%94%E8%AE%B01/"/>
    <id>http://llag9810.github.io/2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/</id>
    <published>2017-03-26T15:35:53.000Z</published>
    <updated>2017-03-27T06:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斯坦福算法课踩坑系列-S01E01"><a href="#斯坦福算法课踩坑系列-S01E01" class="headerlink" title="斯坦福算法课踩坑系列 S01E01"></a>斯坦福算法课踩坑系列 S01E01</h1><h2 id="写在正题前"><a href="#写在正题前" class="headerlink" title="写在正题前"></a>写在正题前</h2><p>还没开始学算法，数据结构也是半吊子。脑抽在 Coursera 上面跟了这门课，上了几节后听别人说另外一门 Prinston 的讲得更接地气，少了很多数学证明，也多了很多实现细节。总之，已经买了也不能中途弃坑。所以自己打算写个长期系列。</p>
<p>言归正传，这门课主要分为以下四个部分：</p>
<ul>
<li>Divide and Conquer, Sorting and Searching, and Randomized Algorithms.</li>
<li>Graph Search, Shortest Paths, and Data Structures.</li>
<li>Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming.</li>
<li>Shortest Paths Revisited, NP-Complete Problems and What To Do About Them.</li>
</ul>
<p>目前我上完了第一部分，也就是分治、排序、搜索和随机算法。</p>
<p>第一集先整理这两个部分：归并排序、寻找逆序对。</p>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/Merge-sort-example.gif" alt="一图流，不展开讲" title="">
                </div>
                <div class="image-caption">一图流，不展开讲</div>
            </figure>
<p>这个没什么可以记笔记的。顾名思义，归并排序分为两步。<br>第一，递归的把数组二分；第二，一层一层的把已经排序的两个小数组进行合并。</p>
<p>伪代码大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    mergeSort(a, n / <span class="number">2</span>);</div><div class="line">    mergeSort(a + n / <span class="number">2</span>, n / <span class="number">2</span>);</div><div class="line">    merge(a, a + n / <span class="number">2</span>, n / <span class="number">2</span>, n - n / <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，前两步分治为两个子问题，最后一步是进行归并。<br>合并的过程也很简单。由于两个子数组已经排好序，所以同时对两个数组，两个指针进行一次遍历即可。<br>自己随手实现了下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> size_a, <span class="keyword">int</span> size_b, <span class="keyword">int</span> temp[])</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; size_a + size_b; count++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a[i] &lt; b[j] &amp;&amp; i &lt; size_a || j == size_b)</div><div class="line">            temp[count] = a[i++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt;= b[j] &amp;&amp; j &lt; size_b || i == size_a)</div><div class="line">            temp[count] = b[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; size_a + size_b; count++) &#123;</div><div class="line">        a[count] = temp[count];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* temp)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    mergeSort(a, n / <span class="number">2</span>, temp);</div><div class="line">    mergeSort(a + n / <span class="number">2</span>, n - n / <span class="number">2</span>, temp + n / <span class="number">2</span>);</div><div class="line"></div><div class="line">    merge(a, a + n / <span class="number">2</span>, n / <span class="number">2</span>, n - n / <span class="number">2</span>, temp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(a));</div><div class="line"></div><div class="line">    mergeSort(a, <span class="number">8</span>, temp);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="寻找逆序对-Counting-Inversions"><a href="#寻找逆序对-Counting-Inversions" class="headerlink" title="寻找逆序对(Counting Inversions)"></a>寻找逆序对(Counting Inversions)</h2><p>要求：</p>
<blockquote>
<p>Input : array A containing the numbers 1,2,3,..,n in some arbitrary order.</p>
<p>Output : number of inversions =  number of pairs(i,j) of array indices with i &lt; j and A[i] &gt; A[j].</p>
</blockquote>
<p>分析：要求的逆序对可以分为三种情况。</p>
<ul>
<li>情况1：i, j都在数组的前半边。</li>
<li>情况2：i, j都在数组的后半边。</li>
<li>情况3：i, j分别位于数组的前、后半边。</li>
</ul>
<p>对于前两种情况，直接递归即可，然后加上第三种情况的结果即为所求。</p>
<p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">count(array A, length n)</div><div class="line">    if n = 1, return 0;</div><div class="line"></div><div class="line">    x = count(half of A, n / 2);</div><div class="line">    y = count(2nd half of A, n / 2);</div><div class="line">    z = countSplitInversion(A, n);     // Not implemented yet</div><div class="line">    </div><div class="line">    return x + y + z;</div></pre></td></tr></table></figure></p>
<p>Goal : implement CountSplitInversions in linear (O(n)) time then count will run in O(nlog(n)) time.</p>
<p>寻找 split inversion 的过程和归并排序的合并过程类似。我们不妨看几个例子：</p>
<ol>
<li><p>假如数组中不存在 Split Inversions</p>
<p> 比如：<code>A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</code></p>
<p> 进行分治后，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = &#123;0, 1, 2, 3, 4&#125;</div><div class="line">B = &#123;5, 6, 7, 8, 9&#125;</div></pre></td></tr></table></figure>
<p> 也就是说，前半个数组中所有的元素都比后半个数组小。对该数组进行归并，使用 i, j 两指针。此时，当 i 走到头时，j 尚未移动。</p>
</li>
<li><p>假如数组中存在 m 个 Split Inversions</p>
<p> 比如：<code>A = {0, 1, 2, 3, 8, 4, 5, 6, 7, 9}</code></p>
<p> 进行分治后，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = &#123;0, 1, 2, 3, 8&#125;</div><div class="line">B = &#123;4, 5, 6, 7, 9&#125;</div></pre></td></tr></table></figure>
<p> 执行归并的过程，i 到终点以后，j 指向7，也就是第4个元素。<br> 这个数组中有4个逆序对。</p>
</li>
</ol>
<p>规律很显然，当一个指针走到头时，另一个指针的位置就是逆序对的个数。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSplitInversions</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> size_a, <span class="keyword">int</span> size_b)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size_a + size_b; k++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i == size_a || j == size_b) <span class="keyword">break</span>;</div><div class="line">        a[i] &lt; b[j] ? i++ : j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i == size_a ? j + <span class="number">1</span> : i + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countInversions</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> x = countInversions(a, n / <span class="number">2</span>);</div><div class="line">    <span class="keyword">int</span> y = countInversions(a + n / <span class="number">2</span>, n - n / <span class="number">2</span>);</div><div class="line">    <span class="keyword">int</span> z = countSplitInversions(a, a + n / <span class="number">2</span>, n / <span class="number">2</span>, n - n / <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> x + y + z;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</div><div class="line">    <span class="keyword">int</span> result = countInversions(a, <span class="number">11</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;斯坦福算法课踩坑系列-S01E01&quot;&gt;&lt;a href=&quot;#斯坦福算法课踩坑系列-S01E01&quot; class=&quot;headerlink&quot; title=&quot;斯坦福算法课踩坑系列 S01E01&quot;&gt;&lt;/a&gt;斯坦福算法课踩坑系列 S01E01&lt;/h1&gt;&lt;h2 id=&quot;写在正题前
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://llag9810.github.io/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制——Handler机制详解</title>
    <link href="http://llag9810.github.io/2017/03/13/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://llag9810.github.io/2017/03/13/Android消息机制——Handler机制详解/</id>
    <published>2017-03-13T10:47:16.000Z</published>
    <updated>2017-03-24T11:25:34.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Handler-机制详解"><a href="#Android-Handler-机制详解" class="headerlink" title="Android Handler 机制详解"></a>Android Handler 机制详解</h1><h2 id="一些基础回顾"><a href="#一些基础回顾" class="headerlink" title="一些基础回顾"></a>一些基础回顾</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><blockquote>
<p>主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。<br>ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。</p>
<p>子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。</p>
</blockquote>
<p>简而言之，就是说：</p>
<ul>
<li>主线程不能执行耗时操作（避免ANR）</li>
<li>子线程不能直接更新UI界面</li>
</ul>
<h3 id="Handler-的简单使用"><a href="#Handler-的简单使用" class="headerlink" title="Handler 的简单使用"></a>Handler 的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> implement this method.</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在新的线程中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Message msg = Message.obtain();</div><div class="line">msg.what = <span class="number">1</span>;</div><div class="line">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/03/13/Android消息机制——Handler机制详解/simplehandlerexample.png" alt="简单的Handler使用" title="">
                </div>
                <div class="image-caption">简单的Handler使用</div>
            </figure>
<p>上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。</p>
<h2 id="Handler-机制的分析理解"><a href="#Handler-机制的分析理解" class="headerlink" title="Handler 机制的分析理解"></a>Handler 机制的分析理解</h2><p>下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。</p>
<h3 id="Message简介"><a href="#Message简介" class="headerlink" title="Message简介"></a>Message简介</h3><p>第一步当然是创建一个消息。在创建新Message时，我们使用<code>Message.obtain()</code>方法来新建一条消息，而不是直接<code>new Message()</code>。我们不妨来看一下obtain方法的源代码</p>
<p>Message的源代码链接：<a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/os/Message.java#Message" target="_blank" rel="external">android.os.Message源代码</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Return a new Message instance from the global pool. Allows us to </div><div class="line"> * avoid allocating new objects in many cases. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;  </div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;  </div><div class="line">            Message m = sPool;  </div><div class="line">            sPool = m.next;  </div><div class="line">            m.next = <span class="keyword">null</span>;  </div><div class="line">            sPoolSize--;  </div><div class="line">            <span class="keyword">return</span> m;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见从<code>obtain()</code>的源代码中我们可以知道,它是静态方法,而且只有在<code>spool == null</code>的情况下才会<code>new</code>出一个<code>Message()</code>,返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。</p>
<p>说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Recycles a Message that may be in-use.</div><div class="line"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></div><div class="line">    <span class="comment">// Clear out all other details.</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们继续深入Message类来看。首先看一下其中几个重要的成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; </div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"><span class="keyword">public</span> Object obj;</div><div class="line">Bundle data;</div><div class="line"></div><div class="line">Handler target;</div><div class="line">Runnable callback;</div><div class="line"></div><div class="line">Message next;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</div></pre></td></tr></table></figure></p>
<p>其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。</p>
<p>target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。<br>callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。</p>
<p>sPool: 消息回收池，是个链表结构。</p>
<p>返回去再看看obtain和recycle方法，是不是清晰多了 : )</p>
<p>小结：</p>
<ul>
<li>使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。</li>
<li>每个message都对应一个发送该消息的Handler。（后面详解）</li>
<li>message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解）</li>
</ul>
<h3 id="MessageQueue-简介"><a href="#MessageQueue-简介" class="headerlink" title="MessageQueue 简介"></a>MessageQueue 简介</h3><p><a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/os/MessageQueue.java" target="_blank" rel="external">MessageQueue源码</a></p>
<p>MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表）</p>
<ul>
<li>插入（入队） enqueueMessage(Message msg, long when)</li>
<li>读取（出队） next()</li>
</ul>
<p>顾名思义。这一部分源代码分析先跳过，随后分析。</p>
<h3 id="Handler-简介"><a href="#Handler-简介" class="headerlink" title="Handler 简介"></a>Handler 简介</h3><p>在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。</p>
<p>首先当然需要new一个Handler，我们来看看Handler的构造函数和注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Default constructor associates this handler with the &#123;<span class="doctag">@link</span> Looper&#125; for the</div><div class="line"> * current thread.</div><div class="line"> *</div><div class="line"> * If this thread does not have a looper, this handler won't be able to receive messages</div><div class="line"> * so an exception is thrown.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>无参的构造函数最终追溯到如下两个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Use the &#123;<span class="doctag">@link</span> Looper&#125; for the current thread with the specified callback interface</div><div class="line"> * and set whether the handler should be asynchronous.</div><div class="line"> *</div><div class="line"> * Handlers are synchronous by default unless this constructor is used to make</div><div class="line"> * one that is strictly asynchronous.</div><div class="line"> *</div><div class="line"> * Asynchronous messages represent interrupts or events that do not require global ordering</div><div class="line"> * with respect to synchronous messages.  Asynchronous messages are not subject to</div><div class="line"> * the synchronization barriers introduced by &#123;<span class="doctag">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> callback The callback interface in which to handle messages, or null.</div><div class="line"> * <span class="doctag">@param</span> async If true, the handler calls &#123;<span class="doctag">@link</span> Message#setAsynchronous(boolean)&#125; for</div><div class="line"> * each &#123;<span class="doctag">@link</span> Message&#125; that is sent to it or &#123;<span class="doctag">@link</span> Runnable&#125; that is posted to it.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@hide</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Use the provided &#123;<span class="doctag">@link</span> Looper&#125; instead of the default one and take a callback</div><div class="line"> * interface in which to handle messages.  Also set whether the handler</div><div class="line"> * should be asynchronous.</div><div class="line"> *</div><div class="line"> * Handlers are synchronous by default unless this constructor is used to make</div><div class="line"> * one that is strictly asynchronous.</div><div class="line"> *</div><div class="line"> * Asynchronous messages represent interrupts or events that do not require global ordering</div><div class="line"> * with respect to synchronous messages.  Asynchronous messages are not subject to</div><div class="line"> * the synchronization barriers introduced by &#123;<span class="doctag">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> looper The looper, must not be null.</div><div class="line"> * <span class="doctag">@param</span> callback The callback interface in which to handle messages, or null.</div><div class="line"> * <span class="doctag">@param</span> async If true, the handler calls &#123;<span class="doctag">@link</span> Message#setAsynchronous(boolean)&#125; for</div><div class="line"> * each &#123;<span class="doctag">@link</span> Message&#125; that is sent to it or &#123;<span class="doctag">@link</span> Runnable&#125; that is posted to it.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@hide</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    mLooper = looper;</div><div class="line">    mQueue = looper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，在新建一个Handler时有两种情况。</p>
<ol>
<li>如果没有指定looper，则构造函数会调用<code>Looper.myLooper()</code>方法来获得当前线程（i.e. 创建当前Handler的线程）的looper，并持有其引用。如果当前线程还没有初始化looper则会抛RuntimeException。</li>
<li>如果指定了looper，那么Handler就持有你指定looper的引用。</li>
</ol>
<p>总而言之，每个Handler都对应有一个Looper。关于Looper的内容下面开始。</p>
<h3 id="Looper-简介"><a href="#Looper-简介" class="headerlink" title="Looper 简介"></a>Looper 简介</h3><p><a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/os/Looper.java#Looper" target="_blank" rel="external">Looper源代码</a></p>
<p>我们先截取部分成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"><span class="keyword">final</span> Thread mThread;</div></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="external">ThreadLocal是什么</a></p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
</blockquote>
<p>下面是looper的prepare方法和其构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  <span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">   * This gives you a chance to create handlers that then reference</div><div class="line">   * this looper, before actually starting the loop. Be sure to call</div><div class="line">   * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">   * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">   */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">     prepare(<span class="keyword">true</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">     &#125;</div><div class="line">     sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line"> &#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">  * Initialize the current thread as a looper, marking it as an</div><div class="line">  * application's main looper. The main looper for your application</div><div class="line">  * is created by the Android environment, so you should never need</div><div class="line">  * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">     prepare(<span class="keyword">false</span>);</div><div class="line">     <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">         <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">         &#125;</div><div class="line">         sMainLooper = myLooper();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，根据ThreadLocal的机理，每个线程都对应一个looper。</p>
<p>我们通过prepare方法创建当前线程对应的looper，也就是调用了私有的构造方法。我们注意到，当looper创建的时候会随之创建一个MessageQueue，一个Looper对应一个MessageQueue。</p>
<p>主线程是个例外，其looper为专门的一个成员变量 sMainLooper。主线程的Looper在Main函数中自动被创建了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</div><div class="line"></div><div class="line">    (前面代码省略..............)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SamplingProfilerIntegration.start();  </div><div class="line">  </div><div class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We  </span></div><div class="line">        <span class="comment">// disable it here, but selectively enable it later (via  </span></div><div class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.  </span></div><div class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);  </div><div class="line">  </div><div class="line">        Environment.initForCurrentUser();  </div><div class="line">  </div><div class="line">        <span class="comment">// Set the reporter for event logging in libcore  </span></div><div class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());  </div><div class="line">  </div><div class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);  </div><div class="line">  </div><div class="line">        Looper.prepareMainLooper();  </div><div class="line">  </div><div class="line">        <span class="comment">// 创建ActivityThread实例  </span></div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </div><div class="line">        thread.attach(<span class="keyword">false</span>);  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;  </div><div class="line">            sMainThreadHandler = thread.getHandler();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        AsyncTask.init();  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;  </div><div class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span>  </div><div class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        Looper.loop();  </div><div class="line">  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合上面分析的Looper可以得到如下结论：</p>
<ul>
<li>每个线程能且只能创建一个对应的looper，主线程的looper比较特殊。</li>
<li>在looper创建时会对应生成当前线程的MessageQueue。</li>
</ul>
<p>也就是说，线程、looper和MessageQueue某种程度上是一一对应的关系。简单来说，我们在一条线程中执行<code>Looper.prepare()</code>方法时，创建了属于这条线程的Looper和MessageQueue.</p>
<ul>
<li>一般情况我们使用无参的构造函数，实际上是把Handler和当前线程的Looper和MessageQueue“绑定”。也就是说在当前线程处理消息。</li>
<li>主线程是个例外，任何一个线程中的Handler都可以绑定主线程的Looper，也就是说，无论哪个线程的Handler都可以往主线程发消息。</li>
</ul>
<p>因为Handler、Looper和Message的三角关系被我强行拆成三个部分很难理解清楚。我先把上述的结论下了。我们再回到Handler的<code>sendMessage()</code>方法，看看一条消息是怎么被发送的。</p>
<h3 id="回到Handler和Looper"><a href="#回到Handler和Looper" class="headerlink" title="回到Handler和Looper"></a>回到Handler和Looper</h3><p>sendMessage有一篮子方法，我们发现，关于send和post的方法里面，调来调去就是几个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">            delayMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>殊途同归，最后10 个方法都进入了enqueueMessage方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前说过，每个message持有一个handler的引用，这个handler就是发送消息的handler，最后也会发回这个handler去处理消息。而发送消息的过程，就是在当前线程的MessageQueue里面enqueue一条消息。</p>
<p>那么，当消息被enqueue到队列之后，Looper是怎么样轮询消息的呢？</p>
<p>Looper有个重要的方法是loop，之前只是简单介绍了looper，但并没有把方法贴出来。现在我们来看看<code>Looper.loop()</code>这一方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前说过，每个message持有一个发送这个消息的handler的引用(target)。</p>
<p>在处理消息时，直接调用了<code>msg.target.dispatchMessage()</code>方法，把消息送回Handler进行处理。</p>
<p>结合之前的内容，再总结一下：</p>
<ul>
<li><p>Handler发送消息仅仅是调用MessageQueue的enqueueMessage向插入一条信息到MessageQueue</p>
</li>
<li><p>Looper不断轮询调用MessageQueue的next方法获得下一条待处理的消息</p>
</li>
<li><p>如果发现message就调用handler的dispatchMessage，ldispatchMessage被成功调用，接着调用handlerMessage()</p>
</li>
</ul>
<p>发送消息的过程已经非常明确了。下面我们来看处理消息的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Subclasses must implement this to receive messages.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>message对象中有一个callback成员变量，如果这个message有callback那么就按照callback的内容去处理。否则就调用正常的handleMessage方法。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作：</p>
<ol>
<li>Handler的post()方法</li>
<li>View的post()方法</li>
<li>Activity的runOnUiThread()方法</li>
</ol>
<p>post方法和sendMessage方法使用类似，只是post的参数是一个Runnable。我们来看看源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span>  </span></div><div class="line">&#123;  </div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，是通过getPostMessage把runnable包装成了一个Message。然后再去发一条message。我们看看这个包装消息的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;  </div><div class="line">    Message m = Message.obtain();  </div><div class="line">    m.callback = r;  </div><div class="line">    <span class="keyword">return</span> m;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法中将消息的callback字段的值指定为传入的Runnable对象。咦？这个callback字段看起来有些眼熟啊，喔！在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法。</p>
<p>那我们快来看下handleCallback()方法中的代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;  </div><div class="line">    message.callback.run();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>竟然就是直接调用了一开始传入的Runnable对象的run()方法。</p>
<p>然后再来看一下View中的post()方法，post方法也是传入一个runnable。源码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    Handler handler;  </div><div class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;  </div><div class="line">        handler = mAttachInfo.mHandler;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        ViewRoot.getRunQueue().post(action);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> handler.post(action);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来就是调用了Handler中的post()方法，我相信已经没有什么必要再做解释了。</p>
<p>最后再来看一下Activity中的runOnUiThread()方法，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;  </div><div class="line">        mHandler.post(action);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        action.run();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。还有什么会比这更清晰明了的吗？</p>
<p>通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助Handler机制来实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Handler机制简单概括如下：</p>
<ol>
<li>每个线程可以初始化一个looper和MessageQueue，主线程在ActivityThread运行时已经有了。</li>
<li>Handler负责发送消息对象，发送时会把消息对象里面的target指向自己，表明“消息是我发的”。</li>
<li>Handler发送消息的过程就是往MessageQueue里面入队的过程。入的是哪个队取决于你的Handler，如果new的时候构造函数为空，那就是当前线程的MessageQueue。之前说了主线程的looper可以在任何地方获得（单独的成员变量），所以任何线程的Handler都可以往主线程的MessageQueue中发消息。</li>
<li>Looper负责轮询消息，每拿到一个消息会根据它的target丢给发消息的那个Handler，调用其dispatchMessage方法去处理。</li>
</ol>
<p>下图盗网上的，自己画不好。顺便求一波Windows和Linux上画这种流程图的工具。</p>
<p>先写那么多，有问题以后再改……</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/03/13/Android消息机制——Handler机制详解/handler_process.png" alt="Handler机制过程图" title="">
                </div>
                <div class="image-caption">Handler机制过程图</div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Handler-机制详解&quot;&gt;&lt;a href=&quot;#Android-Handler-机制详解&quot; class=&quot;headerlink&quot; title=&quot;Android Handler 机制详解&quot;&gt;&lt;/a&gt;Android Handler 机制详解&lt;/h1&gt;&lt;
    
    </summary>
    
    
      <category term="Android" scheme="http://llag9810.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
