<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌妹子的小窝</title>
  <subtitle>Android学习中/想学算法/游走在挂科边缘</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-13T13:22:48.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yifan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android消息机制——Handler机制详解</title>
    <link href="http://yoursite.com/2017/03/13/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/13/Android消息机制——Handler机制详解/</id>
    <published>2017-03-13T10:47:16.000Z</published>
    <updated>2017-03-13T13:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Handler-机制详解"><a href="#Android-Handler-机制详解" class="headerlink" title="Android Handler 机制详解"></a>Android Handler 机制详解</h1><h2 id="一些基础回顾"><a href="#一些基础回顾" class="headerlink" title="一些基础回顾"></a>一些基础回顾</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>一个程序的运行，就是一个进程的在执行，一个进程里面可以拥有很多个线程。</p>
<blockquote>
<p>主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。<br>ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。</p>
<p>子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。</p>
</blockquote>
<p>简而言之，就是说：</p>
<ul>
<li>主线程不能执行耗时操作（避免ANR）</li>
<li>子线程不能直接更新UI界面</li>
</ul>
<h3 id="Handler-的简单使用"><a href="#Handler-的简单使用" class="headerlink" title="Handler 的简单使用"></a>Handler 的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> implement this method.</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在新的线程中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Message msg = Message.obtain();</div><div class="line">msg.what = <span class="number">1</span>;</div><div class="line">mHandler.sendMessage(msg);</div></pre></td></tr></table></figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2017/03/13/Android消息机制——Handler机制详解/simplehandlerexample.png" alt="example" title="">
                </div>
                <div class="image-caption">example</div>
            </figure>
<p>上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。</p>
<h2 id="Handler-机制的分析理解"><a href="#Handler-机制的分析理解" class="headerlink" title="Handler 机制的分析理解"></a>Handler 机制的分析理解</h2><p>下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。</p>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>第一步当然是创建一个消息。在创建新Message时，我们使用<code>Message.obtain()</code>方法来新建一条消息，而不是直接<code>new Message()</code>。我们不妨来看一下obtain方法的源代码</p>
<p>Message的源代码链接：<a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/os/Message.java#Message" target="_blank" rel="external">android.os.Message源代码</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * Return a new Message instance from the global pool. Allows us to </div><div class="line"> * avoid allocating new objects in many cases. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;  </div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;  </div><div class="line">            Message m = sPool;  </div><div class="line">            sPool = m.next;  </div><div class="line">            m.next = <span class="keyword">null</span>;  </div><div class="line">            sPoolSize--;  </div><div class="line">            <span class="keyword">return</span> m;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见从<code>obtain()</code>的源代码中我们可以知道,它是静态方法,而且只有在<code>spool == null</code>的情况下才会<code>new</code>出一个<code>Message()</code>,返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。</p>
<p>说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Recycles a Message that may be in-use.</div><div class="line"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></div><div class="line">    <span class="comment">// Clear out all other details.</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们继续深入Message类来看。首先看一下其中几个重要的成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; </div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"><span class="keyword">public</span> Object obj;</div><div class="line">Bundle data;</div><div class="line"></div><div class="line">Handler target;</div><div class="line">Runnable callback;</div><div class="line"></div><div class="line">Message next;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</div></pre></td></tr></table></figure></p>
<p>其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。</p>
<p>target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。<br>callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。</p>
<p>sPool: 消息回收池，是个链表结构。</p>
<p>返回去再看看obtain和recycle方法，是不是清晰多了 : )</p>
<p>小结：</p>
<ul>
<li>使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。</li>
<li>每个message都对应一个发送该消息的Handler。（后面详解）</li>
<li>message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解）</li>
</ul>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p><a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/os/MessageQueue.java#MessageQueue.enqueueMessage(android.os.Message,long" target="_blank" rel="external">MessageQueue源码</a>)</p>
<p>MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表）</p>
<ul>
<li>插入（入队） enqueueMessage(Message msg, long when)</li>
<li>读取（出队） next()</li>
</ul>
<p>顾名思义。这一部分源代码分析先跳过，随后分析。</p>
<h3 id="Handler-发送消息"><a href="#Handler-发送消息" class="headerlink" title="Handler 发送消息"></a>Handler 发送消息</h3><p>在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。</p>
<p>首先当然需要new一个Handler，我们来看看Handler的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Handler-机制详解&quot;&gt;&lt;a href=&quot;#Android-Handler-机制详解&quot; class=&quot;headerlink&quot; title=&quot;Android Handler 机制详解&quot;&gt;&lt;/a&gt;Android Handler 机制详解&lt;/h1&gt;&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
