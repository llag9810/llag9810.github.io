{"meta":{"title":"萌妹子的小窝","subtitle":"Android学习中/想学算法/游走在挂科边缘","description":"Android learner","author":"yifan","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-03-13T07:13:51.000Z","updated":"2017-03-13T07:13:51.367Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android消息机制——Handler机制详解","slug":"Android消息机制——Handler机制详解","date":"2017-03-13T10:47:16.000Z","updated":"2017-03-13T13:22:48.000Z","comments":true,"path":"2017/03/13/Android消息机制——Handler机制详解/","link":"","permalink":"http://yoursite.com/2017/03/13/Android消息机制——Handler机制详解/","excerpt":"","text":"Android Handler 机制详解一些基础回顾引子一个程序的运行，就是一个进程的在执行，一个进程里面可以拥有很多个线程。 主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。 子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。 简而言之，就是说： 主线程不能执行耗时操作（避免ANR） 子线程不能直接更新UI界面 Handler 的简单使用1234567mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // TODO: implement this method. &#125;&#125;; 在新的线程中：123Message msg = Message.obtain();msg.what = 1;mHandler.sendMessage(msg); example 上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。 Handler 机制的分析理解下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。 Message第一步当然是创建一个消息。在创建新Message时，我们使用Message.obtain()方法来新建一条消息，而不是直接new Message()。我们不妨来看一下obtain方法的源代码 Message的源代码链接：android.os.Message源代码 12345678910111213141516/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 可见从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool == null的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 我们继续深入Message类来看。首先看一下其中几个重要的成员变量1234567891011121314151617public int what;public int arg1; public int arg2;public Object obj;Bundle data;Handler target;Runnable callback;Message next;private static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。 target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。 sPool: 消息回收池，是个链表结构。 返回去再看看obtain和recycle方法，是不是清晰多了 : ) 小结： 使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。 每个message都对应一个发送该消息的Handler。（后面详解） message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解） MessageQueueMessageQueue源码) MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表） 插入（入队） enqueueMessage(Message msg, long when) 读取（出队） next() 顾名思义。这一部分源代码分析先跳过，随后分析。 Handler 发送消息在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。 首先当然需要new一个Handler，我们来看看Handler的构造函数。12","categories":[],"tags":[]}]}