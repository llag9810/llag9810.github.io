{"meta":{"title":"小窝","subtitle":"Android/Java/随便写写","description":"Android learner","author":"yifan","url":"http://llag9810.github.io"},"pages":[{"title":"tags","date":"2017-03-13T07:13:51.000Z","updated":"2017-03-24T11:26:56.847Z","comments":true,"path":"tags/index.html","permalink":"http://llag9810.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 垃圾回收（下篇）及典型的垃圾回收算法","slug":"Java-垃圾回收（下篇）及典型的垃圾回收算法","date":"2018-02-07T13:27:34.000Z","updated":"2018-02-07T14:17:55.000Z","comments":true,"path":"2018/02/07/Java-垃圾回收（下篇）及典型的垃圾回收算法/","link":"","permalink":"http://llag9810.github.io/2018/02/07/Java-垃圾回收（下篇）及典型的垃圾回收算法/","excerpt":"","text":"1. 概述在上篇中，我们提到了什么是 GC、GC 的原理、何时该 GC 等问题，但是具体的垃圾回收算法没有提到。在本篇博客中，我想主要讲述以下几方面内容： 典型的垃圾回收算法 典型的垃圾收集器 内存分配与回收策略 注：本文有部分内容直接摘抄自《深入理解 Java 虚拟机》，也有部分内容直接引用自http://www.cnblogs.com/dolphin0520/p/3783345.html 2. 典型的 GC 算法在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始 GC ，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于 Java 虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。 2.1 Mark-Sweep（标记-清除）算法标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示： 标记-清除算法示意图 从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。 2.2 Copying（复制）算法为了解决 Mark-Sweep 算法的缺陷，Copying 算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示： 复制算法示意图 这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。 很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。 2.3 Mark-Compact（标记-整理）算法为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示： 标记-整理 2.4 Generational Collection（分代收集）算法分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 目前大部分垃圾收集器对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照 1：1 的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将 Eden 和 Survivor 中还存活的对象复制到另一块 Survivor 空间中，然后清理掉Eden和刚才使用过的 Survivor 空间。 而由于老年代的特点是每次回收都只回收少量对象，一般使用的 Mark-Compact算法。 3. 典型的垃圾收集器垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下 HotSpot（JDK 7) 虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。 3.1 Serial/Serial OldSerial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial 收集器是针对新生代的收集器，采用的是 Copying 算法，Serial Old 收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。 3.2 ParNewParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。 3.3 Parallel ScavengeParallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。 3.4 Parallel OldParallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。 3.5 CMSCMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。 3.6 G1G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。 4. 内存分配及回收策略4.1 对象优先在 Eden 分配大多数情况下，对象在新生区 Eden 区中分配，当 Eden 没有足够空间分配时，虚拟机将发起一次 Minor GC，GC后将已有对象放入Survivor中，若 Survivor 空间不足，则通过分配担保机制提前转移到老年代。 4.2 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，例如较长的字符串和较长的数组。虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个值的参数直接在老年代分配。 4.3 长期存活的对象进入老年代虚拟机既然采用了分代收集的思想来管理内存，那么内存回收时就必须能识别对象放在新生代，哪些对象放在老年代。为了做到这点，虚拟机给每个对象定义一个对象年龄计数器。如果对象在Eden出生并经过第一次 Minor GC 然后仍然存活，并且能被 Survivor 容纳的话，将被移到 Survivor 中，并且对象年龄设为 1 。对象在 Survivor 中每过一次 Minor GC，年龄就增加一岁。当年龄增加到一定程度，就会晋升到老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。 4.4 动态对象年龄判定为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到 MaxTenuringThreshold 的要求。 4.5 空间分配担保在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。若不成立，则虚拟机会查看HandlePromotionFailure设置值是否担保失败，若允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小(相当于一个经验值，不保证可以成功)，如果大于，尽管这次 Minor GC 冒险，也会尝试进行一次 Minor GC ；如果小于，或者 HandlePromotionFailure 设置为不允许冒险，那么需要进行一次 Full GC。 5. 小结 典型的 GC 算法包括标记-清除(mark and sweep)、复制(copying)、标记-整理(mark and Compact)。目前的 JVM 大都使用分代收集算法。对于新生代都采取 Copying 算法，老年代采取标记-整理算法。 一般新生代被划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将 Eden 和 Survivor 中还存活的对象复制到另一块 Survivor 空间中，然后清理掉Eden和刚才使用过的 Survivor 空间。 对象优先在 Eden 分配，大对象和长期存活的对象会直接进入老年代。在发生 Minor GC 之前，会检查老年代的最大可用空间来进行空间分配担保。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://llag9810.github.io/tags/JVM/"}]},{"title":"Java 垃圾回收机制（上）—— GC 简介","slug":"Java-虚拟机读书笔记（二）","date":"2017-12-04T15:13:35.000Z","updated":"2018-02-07T14:20:21.821Z","comments":true,"path":"2017/12/04/Java-虚拟机读书笔记（二）/","link":"","permalink":"http://llag9810.github.io/2017/12/04/Java-虚拟机读书笔记（二）/","excerpt":"","text":"1. 概述这篇博客对应的是《深入理解 Java 虚拟机》第三章的部分内容。包括 GC 的简单介绍、判断对象存活的方法、强软弱虚四种引用，还有finalize()方法的简介。有关垃圾回收算法的部分在下篇中填坑。 2. 什么是垃圾回收？说起垃圾回收(Garbage Collection,GC),大部分人都把这项技术当做Java语言的伴生产物。事实上,GC 的历史比 Java 久远,1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言。当 Lisp 还在胚胎时时,人们就在思考 GC 需要完成的3件事情: 哪些内存需要回收? 什么时候回收? 如何回收? 回到我们熟悉的 Java 语言，不妨回顾Java内存运行时区域的各个部分。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由JIT编译器进行一些优化,但在本章基于概念模型的讨论中,大体上可以认为是编译期可知的。)因此这几个区域的内存分配和回收都具备确定性,在这几个区域内就不需要过多考虑回收的问题。因为方法结束或者线程结束时,内存自然就跟随着回收了。 而 Java 堆和方法区则不一样,一个接口中的多个实现类需要的内存可能不一样,一个方法中的多个分支需要的内存也可能不一样,我们只有在程序处于运行期间时才能知道会创建哪些对象,这部分内存的分配和回收都是动态的。 所以垃圾收集器所关注的是这部分（堆和方法区）内存。 3. 判断对象是否“存活”—— GC 算法简介在堆里面存放着 Java 世界中几乎所有的对象实例垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。 下面简要介绍两种判断对象存活的算法:引用计数和可达性分析。 3.1 引用计数引用计数是一种简单的判断对象存活的算法。其算法是这样的： 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1 ；每当有一个引用失效时，计数器值就减 1 。 任何时刻计数器为 0 的对象就是不可能再被使用的对象，即可以被回收的对象。 客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是,至少主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 举个简单的例子，见下面代码中的testGC()方法：对象 objA 和 objB 都有成员变量instance，令objA.instance = objB及objB.instance = objA。除此之外,这两个对象再无任何引用。也就是说实际上这两个对象已经不可能再被访问。 但是，它们因为互相引用着对方，导致它们的引用计数都为1，于是引用计数算法无法通知 GC 收集器回收它们。 （下面代码摘抄自《深入理解 Java 虚拟机》第二版 3.2.1 章节）12345678910111213141516171819202122/***testGC()方法执行后,objA和objB会不会被GC呢?*@author zzm*/public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024*1024; /** *这个成员属性的唯一意义就是占点内存,以便能在GC日志中看清楚是否被回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; //假设在这行发生GC,objA和objB是否能被回收? System.gc(); &#125;&#125; 运行结果（摘抄自书籍）：1234567891011[FullGC(System)[Tenured:0K-&gt;210K(10240K),0.0149142secs]4603K-&gt;210K(19456K),[Perm:2999K-&gt;2999K(21248K)],0.0150007 secs][Times:user=0.01 sys=0.00,real=0.02 secs]Heapdef new generation total 9216K,used 82K[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Eden space 8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)from space 1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)to space 1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)tenured generation total 10240K,used 210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)the space 10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)compacting perm gen total 21248K,used 3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)the space 21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)No shared spaces configured. 很显然，日志中的”4603k -&gt; 210k”说明这两个对象成功的被回收。这也从侧面说明了虚拟机并不是通过引用计数来实现垃圾回收的。 3.2 可达性分析在目前的主流语言中，基本上都是通过可达性分析(Reachability Analysis)来判定对象的存活与否。 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 可达性分析判断回收 在Java中，作为 GC root 的引用一般包括： 栈(栈帧中的局部变量)中引用的对象。 方法区中类静态成员变量引用的对象。 方法区中常量引用的对象。 native 方法栈中 JNI（Native 方法）引用的对象。 4. 强、软、弱、虚四种引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。Java 中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘。 我们希望描述下面这种对象：当内存空间足够时，保留在内存中。当空间十分紧张时，则可以回收这些对象。于是，在 jdk 1.2以后，Java 对引用的概念进行了扩充。将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种,这4种引用强度依次逐渐减弱。 强引用就是指在程序代码之中普遍存在的,类似Object obj = new Object()这类的引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被弱引用关联的对象。WeakReference类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。 5. 生存还是死亡？—— finalize() 方法简介虚拟机通常使用可达性分析的方式来判断对象能否回收。即使在可达性分析算法中不可达的对象，也并非是“非死不可”的。 这时候它们暂时处于“缓刑”阶段。要真正宣告一个对象死亡，至少要经历两次标记过程。 第一次筛选的方式如下： 如果对象在进行可达性分析后发现没有与 GC Root 相连接的引用链，那它将会被第一次标记并且进行一次筛选。 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有重写finalize()方法。或者finalize()方法已经被虚拟机调用过了，虚拟机将这两种情况都视为“没有必要执行”。 也就是说，执行finalize()的条件有两个：一是当前对象的类重写了finalize()方法，二是虚拟机先前还没有调用过该方法。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致 F-Queue 队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记。 如果对象想要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合。如果对象这时候还没有逃脱，那基本上它就真的被回收了。 从下面的代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。（代码摘自《深入理解 Java 虚拟机》3.2章节）1234567891011121314151617181920212223242526272829303132333435363738394041424344/***此代码演示了两点:*1. 对象可以在被GC时自我拯救。*2. 这种自救的机会只有一次,因为一个对象的finalize()方法最多只会被系统自动调用一次*@author zzm*/public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println(\"yes,i am still alive:)\"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"finalize mehtod executed!\"); // 将自身赋值给一个静态成员变量，进行自我拯救 FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable &#123; SAVE_HOOK = new FinalizeEscapeGC(); // 将SAVE_HOOK置null，使对象不可达。触发自救 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低,所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(\"no,i am dead:(\"); &#125; // 下面这段代码与上面的完全相同,但是这次自救却失败了 SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(\"no,i am dead:(\"); &#125; &#125;&#125; 运行结果：123finalize mehtod executed!yes,i am still alive:)no,i am dead:( 从结果可以看出，第一次SAVE_HOOK 对象的finalize()方法确实被 GC 收集器触发过,并且在被收集前成功逃脱了。另外一个值得注意的地方是，main函数代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的finalize()方法都只会被系统自动调用一次。如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。 6. 回收方法区很多人认为方法区(或者 HotSpot 虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中, 但是当前系统没有任何一个 String 对象是叫做“abc”的, 换句话说,就是没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”: 该类所有的实例都已经被回收,也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 7. 小结 判断对象能否回收的算法包括引用计数和可达性分析两种。前者实现较为简单，但是会有循环引用的问题。目前的主流语言使用的都是后者。在 Java 中，GC root 包括栈中的引用对象，方法区中的 static 引用和常量、native 方法中引用的对象。 强、软、弱、虚四种引用强度依次减弱。其中，强引用即代码中最常见的赋值引用，强引用只要存在就不会被回收。后面三种引用都是用 Java 中提供的类来使用。其中软引用会在系统即将发生内存异常时列入回收范围，当回收后内存依然不够时，会被回收。弱引用只要 GC 工作，无论内存足够与否都会被回收。虚引用无法通过其获得对象示例，只是会在被回收时通知。 在 GC 时调用finalize()需要满足两个条件：当前对象的类重写了finalize()方法，二是虚拟机先前还没有调用过该方法。如果这个对象被判定为有必要执行finalize()方法，会放置在 F-Queue 中由低优先级线程 Finalizer 来执行。如果对象想要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。每个对象的finalize()只能执行一次，也就是说只有一次机会。 最后引用书本上的一段话结束这篇博客： 需要特别说明的是，上面关于对象死亡时 finalize() 方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize()能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://llag9810.github.io/tags/JVM/"}]},{"title":"ArrayList 源码解析","slug":"ArrayList-源码解析","date":"2017-09-03T04:41:55.000Z","updated":"2018-02-03T05:21:39.116Z","comments":true,"path":"2017/09/03/ArrayList-源码解析/","link":"","permalink":"http://llag9810.github.io/2017/09/03/ArrayList-源码解析/","excerpt":"","text":"ArrayList 简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 实现了 RandmoAccess 接口，即提供了随机访问功能。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过 Iterator 迭代器访问”的效率。 ArrayList 实现了 Cloneable 接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。 下面让我们翻开 ArrayList 的源代码，看看一些常用的方法属性，以及一些需要注意的地方。 ArrayList 属性ArrayList 属性主要就是当前数组长度size，以及存放数组的对象 elementData 数组，除此之外还有一个经常用到的属性就是从 AbstractList 继承过来的 modCount 属性，代表ArrayList集合的修改次数。关于modCount的作用后面讲到。 123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123; // 序列化id private static final long serialVersionUID = 8683452581122892189L; // 默认初始的容量 private static final int DEFAULT_CAPACITY = 10; // 一个空对象 private static final Object[] EMPTY_ELEMENTDATA = new Object[0]; // 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0]; // 当前数据对象存放地方，当前对象不参与序列化 transient Object[] elementData; // 当前数组长度 private int size; // 数组最大长度 private static final int MAX_ARRAY_SIZE = 2147483639; // 省略方法&#125; ArrayList 构造函数默认构造函数（空参数）也就是我们最常用的不带参数的构造，如果不传入参数，则使用默认无参构建方法创建ArrayList对象，如下：123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 注意：此时我们创建的ArrayList对象中的 elementData 中的长度是1，size 是 0 ,当进行第一次add的时候，elementData 将会变成默认的长度：10。 接受一个 int 参数构造函数如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; 接受一个 Collection 的构造在构造一个 ArrayList 时，可以直接传入一个Collection，将已有的集合构造为一个 List。构造过程可以概括为： (1) 将collection对象转换成数组，然后将数组的地址的赋给elementData。 (2) 更新size的值，同时判断size的大小，如果是size等于0，直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData (3) 如果size的值大于0，则执行Arrays.copy方法，把 collection 对象的内容（可以理解为深拷贝）copy到elementData中。 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; add 方法add 的方法有两个，一个是带一个参数的，一个是带两个参数的，下面我们一个个讲解。 一个参数的 addadd(E e) 方法主要的执行逻辑如下： 1）确保数组已使用长度（size）加1之后足够存下 下一个数据 2）修改次数modCount 标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组，grow方法会将当前数组的长度变为原来容量的1.5倍。 3）确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 4）返回添加成功布尔值。 123456public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 确保添加的元素有地方存储，当第一次添加元素的时候this.size+1 的值是1，所以第一次添加的时候会将当前elementData数组的长度变为10：1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 将修改次数（modCount）自增1，判断是否需要扩充数组长度,判断条件就是用当前所需的数组最小长度与数组的长度对比，如果大于0，则增长数组长度。1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 如果当前的数组已使用空间（size）加1之后 大于数组长度，则增大数组容量，扩大为原来的1.5倍。12345678910111213private void grow(int arg0) &#123; int arg1 = this.elementData.length; int arg2 = arg1 + (arg1 &gt;&gt; 1); if (arg2 - arg0 &lt; 0) &#123; arg2 = arg0; &#125; if (arg2 - 2147483639 &gt; 0) &#123; arg2 = hugeCapacity(arg0); &#125; this.elementData = Arrays.copyOf(this.elementData, arg2); &#125; 两个参数的 addadd(int index, E element)方法其实和上面的add类似，该方法可以按照元素的位置，指定位置插入元素，具体的执行逻辑如下： 1）确保数插入的位置小于等于当前数组长度，并且不小于0，否则抛出异常 2）确保数组已使用长度（size）加1之后足够存下 下一个数据 3）修改次数（modCount）标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组 4）grow方法会将当前数组的长度变为原来容量的1.5倍。 5）确保有足够的容量之后，使用System.arraycopy 将需要插入的位置（index）后面的元素统统往后移动一位。 6）将新的数据内容存放到数组的指定位置（index）上。123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 注意：使用该方法的话将导致指定位置后面的数组元素全部重新移动，即往后移动一位。 get 方法返回指定位置元素。不多讲12345public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; set方法确保set的位置小于当前数组的长度（size）并且大于0，获取指定位置（index）元素，然后放到 oldValue 存放，将需要设置的元素放到指定的位置（index）上，然后将原来位置上的元素 oldValue 返回给用户。1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; contains方法调用 indexOf 方法，遍历数组中的每一个元素作对比，如果找到对于的元素，则返回 true，没有找到则返回 false。 123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; remove方法根据 index 下标 remove1）判断下标有没有越界 2）自增 modCount 3）将指定位置（index）上的元素保存到 oldValue 4）将指定位置（index）上的元素都往前移动一位 5）将最后面的一个元素置空，好让垃圾回收器回收 6）将原来的值 oldValue 返回 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 注意：调用这个方法不会缩减数组的长度，只是将最后一个数组元素置空而已。 根据对象remove循环遍历所有对象，得到对象所在索引位置，然后调用fastRemove方法，执行remove操作 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 定位到需要remove的元素索引，先将index后面的元素往前面移动一位（调用System.arrayCopy实现），然后将最后一个元素置空。12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; trimToSize方法1）modCount 加1 2）将 elementData 中空余的空间（包括null值）去除，例如：数组长度为10，其中只有前三个元素有值，其他为空，那么调用该方法之后，数组的长度变为3。12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; iteratoriterator 方法返回的是一个内部类，由于内部类的创建默认含有外部的 this指针，所以这个内部类可以调用到外部类的属性。123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 一般的话，调用完iterator()之后，我们会使用迭代器做遍历，这里使用next做遍历的时候有个需要注意的地方，就是调用next的时候，可能会引发ConcurrentModificationException，当修改次数，与期望的修改次数（调用iterator方法时候的修改次数）不一致的时候，会发生该异常，详细我们看一下代码实现：123456789101112@SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; expectedModCount 这个值是在用户调用 ArrayList 的 iterator 方法时候确定的，但是在这之后用户 add ，或者 remove 了 ArrayList 的元素，那么 modCount 就会改变，那么这个值就会不相等，将会引发 ConcurrentModificationException 异常，这个是在多线程使用情况下，比较常见的一个异常。1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 小结ArrayList还有以下一些特点： ArrayList自己实现了序列化和反序列化的方法，因为它自己实现了 private void writeObject(java.io.ObjectOutputStream s)和 private void readObject(java.io.ObjectInputStream s)方法 ArrayList基于数组方式实现，无容量的限制（数组填满时会扩容至原容量的1.5倍） 删除元素时不会减少容量（若希望减少容量，trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。 线程不安全 add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位 get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)） remove(Object o)需要遍历数组 remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高 contains(E)需要遍历数组 使用iterator遍历时不能做修改，否则会引发多线程异常","categories":[],"tags":[]},{"title":"Java 虚拟机（一）","slug":"Java-虚拟机（一）","date":"2017-06-21T10:57:08.000Z","updated":"2018-02-05T15:13:21.000Z","comments":true,"path":"2017/06/21/Java-虚拟机（一）/","link":"","permalink":"http://llag9810.github.io/2017/06/21/Java-虚拟机（一）/","excerpt":"","text":"这部分博客对应的是《深入理解 Java 虚拟机》第二章的部分内容，关于 OOM 异常的部分后面再填坑。 运行时数据区 Runtime Data AreaJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据Java虚拟机规范的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。 Runtime data area 单个线程内共享的区： PC Register 寄存器 JVM Stack 虚拟机栈 Native Method Stack 本地方法栈 所有线程共享的区： Heap 堆 Method Area 方法区，including Runtime Constant Pool 常量池 PC Register程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值是未定义的。 JVM Stack每个线程对应一个Java虚拟机栈。在线程创建时同时创建。用于存储栈帧。JVM栈和一般语言，比如 C 语言的栈类似：它存储局部变量和与一些尚未算好的结果，在方法调用和返回时起到很重要作用。因为除了栈帧的出栈和入栈之外，Java 虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。Java 虚拟机栈所使用的内存不需要保证是连续的。 （请注意避免混淆 Stack、Heap 和 Java Stack、Java Heap 的概念，Java 虚拟机的实现本质上是由其他语言所编写的应用程序，Java 语言程序里分配在 Java Stack 中的数据，从实现虚拟机的程序角度上看则可能分配在 Heap 之中） native stackJava 虚拟机实现可能会使用到传统的栈（通常称为 C stack）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（native method stack）。当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也可以使用本地方法栈。如果 Java 虚拟机不支持 native 方法，或是本身不依赖传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。Java 虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。 Java HeapJava 虚拟机中，堆（heap）是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（automatic storage management system，也就是常说的 garbage collector（GC, 垃圾收集器））所管理的各种对象。 方法区在 Java 虚拟机中，方法区（method area）是可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区（storage area for compiled code）或者操作系统进程的正文段（text segment）的作用非常类似，它存储了每一个类的结构信息，例如，运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。这个版本的 Java 虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。 Java堆栈示意图 Class 文件简介概述class文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活，它甚至比Java源文件有着更强的描述能力。 class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。 class文件 class文件结构 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count 魔数、版本号magic在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： 0XCAFEBABE 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别。 minor_version 和 major_version紧接着魔数的四个字节是class文件的此版本号和主版本号。 随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。 常量池在class文件中， 位于版本号后面的就是常量池相关的数据项。 常量池是class文件中的一项非常重要的数据。 常量池中存放了文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符， 对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的this_class, super_class, field_info, attribute_info等， 另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。 此外， 常量池中各个项也会相互引用。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://llag9810.github.io/tags/JVM/"}]},{"title":"Stanford Algorithms Divide and Conquer笔记","slug":"Stanford-Algorithms-Divide-and-Conquer笔记1","date":"2017-03-26T15:35:53.000Z","updated":"2018-02-05T15:11:18.000Z","comments":true,"path":"2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","link":"","permalink":"http://llag9810.github.io/2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","excerpt":"","text":"斯坦福算法课踩坑系列 S01E01写在正题前还没开始学算法，数据结构也是半吊子。脑抽在 Coursera 上面跟了这门课，上了几节后听别人说另外一门 Prinston 的讲得更接地气，少了很多数学证明，也多了很多实现细节。总之，已经买了也不能中途弃坑。所以自己打算写个长期系列。 言归正传，这门课主要分为以下四个部分： Divide and Conquer, Sorting and Searching, and Randomized Algorithms. Graph Search, Shortest Paths, and Data Structures. Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming. Shortest Paths Revisited, NP-Complete Problems and What To Do About Them. 目前我上完了第一部分，也就是分治、排序、搜索和随机算法。 第一集先整理这两个部分：归并排序、寻找逆序对。 归并排序(Merge Sort) 一图流，不展开讲 这个没什么可以记笔记的。顾名思义，归并排序分为两步。第一，递归的把数组二分；第二，一层一层的把已经排序的两个小数组进行合并。 伪代码大致如下：12345678void mergeSort(int a[], int n) &#123; if (n == 1) return; mergeSort(a, n / 2); mergeSort(a + n / 2, n / 2); merge(a, a + n / 2, n / 2, n - n / 2);&#125; 其中，前两步分治为两个子问题，最后一步是进行归并。合并的过程也很简单。由于两个子数组已经排好序，所以同时对两个数组，两个指针进行一次遍历即可。自己随手实现了下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void merge(int a[], int b[], int size_a, int size_b, int temp[]) &#123; int i = 0; int j = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt; b[j] &amp;&amp; i &lt; size_a || j == size_b) temp[count] = a[i++]; else if (a[i] &gt;= b[j] &amp;&amp; j &lt; size_b || i == size_a) temp[count] = b[j++]; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125;&#125;void mergeSort(int* a, int n, int* temp) &#123; if (n == 1) return; mergeSort(a, n / 2, temp); mergeSort(a + n / 2, n - n / 2, temp + n / 2); merge(a, a + n / 2, n / 2, n - n / 2, temp);&#125;int main() &#123; int a[] = &#123;3, 5, 8, 6, 7, 4, 2, 1&#125;; int *temp = (int *)malloc(sizeof(a)); mergeSort(a, 8, temp); for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) &#123; printf(\"%d \", temp[i]); &#125; return 0;&#125; 寻找逆序对(Counting Inversions)要求： Input : array A containing the numbers 1,2,3,..,n in some arbitrary order. Output : number of inversions = number of pairs(i,j) of array indices with i &lt; j and A[i] &gt; A[j]. 分析：要求的逆序对可以分为三种情况。 情况1：i, j都在数组的前半边。 情况2：i, j都在数组的后半边。 情况3：i, j分别位于数组的前、后半边。 对于前两种情况，直接递归即可，然后加上第三种情况的结果即为所求。 伪代码如下：12345678count(array A, length n) if n = 1, return 0; x = count(half of A, n / 2); y = count(2nd half of A, n / 2); z = countSplitInversion(A, n); // Not implemented yet return x + y + z; Goal : implement CountSplitInversions in linear (O(n)) time then count will run in O(nlog(n)) time. 寻找 split inversion 的过程和归并排序的合并过程类似。我们不妨看几个例子： 假如数组中不存在 Split Inversions 比如：A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 4&#125;B = &#123;5, 6, 7, 8, 9&#125; 也就是说，前半个数组中所有的元素都比后半个数组小。对该数组进行归并，使用 i, j 两指针。此时，当 i 走到头时，j 尚未移动。 假如数组中存在 m 个 Split Inversions 比如：A = {0, 1, 2, 3, 8, 4, 5, 6, 7, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 8&#125;B = &#123;4, 5, 6, 7, 9&#125; 执行归并的过程，i 到终点以后，j 指向7，也就是第4个元素。 这个数组中有4个逆序对。 规律很显然，当一个指针走到头时，另一个指针的位置就是逆序对的个数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int countSplitInversions(int *a, int *b, int size_a, int size_b, int *temp) &#123; int i = 0; int j = 0; int num = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt;= b[j] &amp;&amp; i != size_a || j == size_b) &#123; temp[count] = a[i++]; num += j; &#125; else if(a[i] &gt; b[j] &amp;&amp; j != size_b || i == size_a) &#123; temp[count] = b[j++]; &#125; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125; return num;&#125;int countInversions(int *a, int n, int *temp) &#123; if (n == 1) return 0; int x = countInversions(a, n / 2, temp); int y = countInversions(a + n / 2, n - n / 2, temp + n / 2); int z = countSplitInversions(a, a + n / 2, n / 2, n - n / 2, temp); return x + y + z;&#125;int main() &#123; int a[] = &#123;1, 5, 6, 4, 10, 2, 11, 22, 8, 7, 9&#125;; int *temp = (int *)malloc(sizeof(a)); int result = countInversions(a, 11, temp); printf(\"%d\\n\", result); return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://llag9810.github.io/tags/算法/"}]},{"title":"Android消息机制——Handler机制详解","slug":"Android消息机制——Handler机制详解","date":"2017-03-13T10:47:16.000Z","updated":"2017-03-24T11:25:34.276Z","comments":true,"path":"2017/03/13/Android消息机制——Handler机制详解/","link":"","permalink":"http://llag9810.github.io/2017/03/13/Android消息机制——Handler机制详解/","excerpt":"","text":"Android Handler 机制详解一些基础回顾引子 主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。 子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。 简而言之，就是说： 主线程不能执行耗时操作（避免ANR） 子线程不能直接更新UI界面 Handler 的简单使用1234567mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // TODO: implement this method. &#125;&#125;; 在新的线程中：123Message msg = Message.obtain();msg.what = 1;mHandler.sendMessage(msg); 简单的Handler使用 上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。 Handler 机制的分析理解下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。 Message简介第一步当然是创建一个消息。在创建新Message时，我们使用Message.obtain()方法来新建一条消息，而不是直接new Message()。我们不妨来看一下obtain方法的源代码 Message的源代码链接：android.os.Message源代码 12345678910111213141516/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 可见从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool == null的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 我们继续深入Message类来看。首先看一下其中几个重要的成员变量1234567891011121314151617public int what;public int arg1; public int arg2;public Object obj;Bundle data;Handler target;Runnable callback;Message next;private static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。 target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。 sPool: 消息回收池，是个链表结构。 返回去再看看obtain和recycle方法，是不是清晰多了 : ) 小结： 使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。 每个message都对应一个发送该消息的Handler。（后面详解） message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解） MessageQueue 简介MessageQueue源码 MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表） 插入（入队） enqueueMessage(Message msg, long when) 读取（出队） next() 顾名思义。这一部分源代码分析先跳过，随后分析。 Handler 简介在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。 首先当然需要new一个Handler，我们来看看Handler的构造函数和注释。12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; 无参的构造函数最终追溯到如下两个构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;/** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. Also set whether the handler * should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可见，在新建一个Handler时有两种情况。 如果没有指定looper，则构造函数会调用Looper.myLooper()方法来获得当前线程（i.e. 创建当前Handler的线程）的looper，并持有其引用。如果当前线程还没有初始化looper则会抛RuntimeException。 如果指定了looper，那么Handler就持有你指定looper的引用。 总而言之，每个Handler都对应有一个Looper。关于Looper的内容下面开始。 Looper 简介Looper源代码 我们先截取部分成员变量 12345static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue;final Thread mThread; ThreadLocal是什么 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). 下面是looper的prepare方法和其构造函数123456789101112131415161718192021222324252627282930313233 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 12345678910111213/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 也就是说，根据ThreadLocal的机理，每个线程都对应一个looper。 我们通过prepare方法创建当前线程对应的looper，也就是调用了私有的构造方法。我们注意到，当looper创建的时候会随之创建一个MessageQueue，一个Looper对应一个MessageQueue。 主线程是个例外，其looper为专门的一个成员变量 sMainLooper。主线程的Looper在Main函数中自动被创建了。 1234567891011121314151617181920212223242526272829303132333435363738394041public final class ActivityThread &#123; (前面代码省略..............) public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; &#125; 结合上面分析的Looper可以得到如下结论： 每个线程能且只能创建一个对应的looper，主线程的looper比较特殊。 在looper创建时会对应生成当前线程的MessageQueue。 也就是说，线程、looper和MessageQueue某种程度上是一一对应的关系。简单来说，我们在一条线程中执行Looper.prepare()方法时，创建了属于这条线程的Looper和MessageQueue. 一般情况我们使用无参的构造函数，实际上是把Handler和当前线程的Looper和MessageQueue“绑定”。也就是说在当前线程处理消息。 主线程是个例外，任何一个线程中的Handler都可以绑定主线程的Looper，也就是说，无论哪个线程的Handler都可以往主线程发消息。 因为Handler、Looper和Message的三角关系被我强行拆成三个部分很难理解清楚。我先把上述的结论下了。我们再回到Handler的sendMessage()方法，看看一条消息是怎么被发送的。 回到Handler和LoopersendMessage有一篮子方法，我们发现，关于send和post的方法里面，调来调去就是几个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis) &#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r) &#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 殊途同归，最后10 个方法都进入了enqueueMessage方法。1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 之前说过，每个message持有一个handler的引用，这个handler就是发送消息的handler，最后也会发回这个handler去处理消息。而发送消息的过程，就是在当前线程的MessageQueue里面enqueue一条消息。 那么，当消息被enqueue到队列之后，Looper是怎么样轮询消息的呢？ Looper有个重要的方法是loop，之前只是简单介绍了looper，但并没有把方法贴出来。现在我们来看看Looper.loop()这一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 之前说过，每个message持有一个发送这个消息的handler的引用(target)。 在处理消息时，直接调用了msg.target.dispatchMessage()方法，把消息送回Handler进行处理。 结合之前的内容，再总结一下： Handler发送消息仅仅是调用MessageQueue的enqueueMessage向插入一条信息到MessageQueue Looper不断轮询调用MessageQueue的next方法获得下一条待处理的消息 如果发现message就调用handler的dispatchMessage，ldispatchMessage被成功调用，接着调用handlerMessage() 发送消息的过程已经非常明确了。下面我们来看处理消息的过程。123456789101112131415161718192021/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125;/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; message对象中有一个callback成员变量，如果这个message有callback那么就按照callback的内容去处理。否则就调用正常的handleMessage方法。 题外话除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作： Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 post方法和sendMessage方法使用类似，只是post的参数是一个Runnable。我们来看看源代码1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 很明显，是通过getPostMessage把runnable包装成了一个Message。然后再去发一条message。我们看看这个包装消息的方法12345private final Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; 在这个方法中将消息的callback字段的值指定为传入的Runnable对象。咦？这个callback字段看起来有些眼熟啊，喔！在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法。 那我们快来看下handleCallback()方法中的代码吧：123private final void handleCallback(Message message) &#123; message.callback.run(); &#125; 竟然就是直接调用了一开始传入的Runnable对象的run()方法。 然后再来看一下View中的post()方法，post方法也是传入一个runnable。源码如下所示：12345678910public boolean post(Runnable action) &#123; Handler handler; if (mAttachInfo != null) &#123; handler = mAttachInfo.mHandler; &#125; else &#123; ViewRoot.getRunQueue().post(action); return true; &#125; return handler.post(action); &#125; 原来就是调用了Handler中的post()方法，我相信已经没有什么必要再做解释了。 最后再来看一下Activity中的runOnUiThread()方法，代码如下所示：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。还有什么会比这更清晰明了的吗？ 通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助Handler机制来实现。 总结Handler机制简单概括如下： 每个线程可以初始化一个looper和MessageQueue，主线程在ActivityThread运行时已经有了。 Handler负责发送消息对象，发送时会把消息对象里面的target指向自己，表明“消息是我发的”。 Handler发送消息的过程就是往MessageQueue里面入队的过程。入的是哪个队取决于你的Handler，如果new的时候构造函数为空，那就是当前线程的MessageQueue。之前说了主线程的looper可以在任何地方获得（单独的成员变量），所以任何线程的Handler都可以往主线程的MessageQueue中发消息。 Looper负责轮询消息，每拿到一个消息会根据它的target丢给发消息的那个Handler，调用其dispatchMessage方法去处理。 下图盗网上的，自己画不好。顺便求一波Windows和Linux上画这种流程图的工具。 先写那么多，有问题以后再改…… Handler机制过程图","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://llag9810.github.io/tags/Android/"}]}]}