{"meta":{"title":"萌妹子的小窝","subtitle":"Android学习中/想学算法/游走在挂科边缘","description":"Android learner","author":"yifan","url":"http://llag9810.github.io"},"pages":[{"title":"tags","date":"2017-03-13T07:13:51.000Z","updated":"2017-03-24T11:26:56.847Z","comments":true,"path":"tags/index.html","permalink":"http://llag9810.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 虚拟机（一）","slug":"Java-虚拟机（一）","date":"2017-06-21T10:57:08.000Z","updated":"2017-06-21T11:58:09.000Z","comments":true,"path":"2017/06/21/Java-虚拟机（一）/","link":"","permalink":"http://llag9810.github.io/2017/06/21/Java-虚拟机（一）/","excerpt":"","text":"运行时数据区 Runtime Data AreaJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据Java虚拟机规范的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。 Runtime data area 单个线程内共享的区： PC Register 寄存器 JVM Stack 虚拟机栈 Native Method Stack 本地方法栈 所有线程共享的区： Heap 堆 Method Area 方法区，including Runtime Constant Pool 常量池 PC Register程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值是未定义的。 JVM Stack每个线程对应一个Java虚拟机栈。在线程创建时同时创建。用于存储栈帧。JVM栈和一般语言，比如 C 语言的栈类似：它存储局部变量和与一些尚未算好的结果，在方法调用和返回时起到很重要作用。因为除了栈帧的出栈和入栈之外，Java 虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。Java 虚拟机栈所使用的内存不需要保证是连续的。 （请注意避免混淆 Stack、Heap 和 Java Stack、Java Heap 的概念，Java 虚拟机的实现本质上是由其他语言所编写的应用程序，Java 语言程序里分配在 Java Stack 中的数据，从实现虚拟机的程序角度上看则可能分配在 Heap 之中） native stackJava 虚拟机实现可能会使用到传统的栈（通常称为 C stack）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（native method stack）。当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也可以使用本地方法栈。如果 Java 虚拟机不支持 native 方法，或是本身不依赖传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。Java 虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。 Java HeapJava 虚拟机中，堆（heap）是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（automatic storage management system，也就是常说的 garbage collector（GC, 垃圾收集器））所管理的各种对象。 方法区在 Java 虚拟机中，方法区（method area）是可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区（storage area for compiled code）或者操作系统进程的正文段（text segment）的作用非常类似，它存储了每一个类的结构信息，例如，运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。这个版本的 Java 虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。 Runtime data area","categories":[],"tags":[]},{"title":"Stanford Algorithms Divide and Conquer笔记","slug":"Stanford-Algorithms-Divide-and-Conquer笔记1","date":"2017-03-26T15:35:53.000Z","updated":"2017-05-13T08:37:45.006Z","comments":true,"path":"2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","link":"","permalink":"http://llag9810.github.io/2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","excerpt":"","text":"斯坦福算法课踩坑系列 S01E01写在正题前还没开始学算法，数据结构也是半吊子。脑抽在 Coursera 上面跟了这门课，上了几节后听别人说另外一门 Prinston 的讲得更接地气，少了很多数学证明，也多了很多实现细节。总之，已经买了也不能中途弃坑。所以自己打算写个长期系列。 言归正传，这门课主要分为以下四个部分： Divide and Conquer, Sorting and Searching, and Randomized Algorithms. Graph Search, Shortest Paths, and Data Structures. Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming. Shortest Paths Revisited, NP-Complete Problems and What To Do About Them. 目前我上完了第一部分，也就是分治、排序、搜索和随机算法。 第一集先整理这两个部分：归并排序、寻找逆序对。 归并排序(Merge Sort) 一图流，不展开讲 这个没什么可以记笔记的。顾名思义，归并排序分为两步。第一，递归的把数组二分；第二，一层一层的把已经排序的两个小数组进行合并。 伪代码大致如下：12345678void mergeSort(int a[], int n) &#123; if (n == 1) return; mergeSort(a, n / 2); mergeSort(a + n / 2, n / 2); merge(a, a + n / 2, n / 2, n - n / 2);&#125; 其中，前两步分治为两个子问题，最后一步是进行归并。合并的过程也很简单。由于两个子数组已经排好序，所以同时对两个数组，两个指针进行一次遍历即可。自己随手实现了下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void merge(int a[], int b[], int size_a, int size_b, int temp[]) &#123; int i = 0; int j = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt; b[j] &amp;&amp; i &lt; size_a || j == size_b) temp[count] = a[i++]; else if (a[i] &gt;= b[j] &amp;&amp; j &lt; size_b || i == size_a) temp[count] = b[j++]; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125;&#125;void mergeSort(int* a, int n, int* temp) &#123; if (n == 1) return; mergeSort(a, n / 2, temp); mergeSort(a + n / 2, n - n / 2, temp + n / 2); merge(a, a + n / 2, n / 2, n - n / 2, temp);&#125;int main() &#123; int a[] = &#123;3, 5, 8, 6, 7, 4, 2, 1&#125;; int *temp = (int *)malloc(sizeof(a)); mergeSort(a, 8, temp); for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) &#123; printf(\"%d \", temp[i]); &#125; return 0;&#125; 寻找逆序对(Counting Inversions)要求： Input : array A containing the numbers 1,2,3,..,n in some arbitrary order. Output : number of inversions = number of pairs(i,j) of array indices with i &lt; j and A[i] &gt; A[j]. 分析：要求的逆序对可以分为三种情况。 情况1：i, j都在数组的前半边。 情况2：i, j都在数组的后半边。 情况3：i, j分别位于数组的前、后半边。 对于前两种情况，直接递归即可，然后加上第三种情况的结果即为所求。 伪代码如下：12345678count(array A, length n) if n = 1, return 0; x = count(half of A, n / 2); y = count(2nd half of A, n / 2); z = countSplitInversion(A, n); // Not implemented yet return x + y + z; Goal : implement CountSplitInversions in linear (O(n)) time then count will run in O(nlog(n)) time. 寻找 split inversion 的过程和归并排序的合并过程类似。我们不妨看几个例子： 假如数组中不存在 Split Inversions 比如：A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 4&#125;B = &#123;5, 6, 7, 8, 9&#125; 也就是说，前半个数组中所有的元素都比后半个数组小。对该数组进行归并，使用 i, j 两指针。此时，当 i 走到头时，j 尚未移动。 假如数组中存在 m 个 Split Inversions 比如：A = {0, 1, 2, 3, 8, 4, 5, 6, 7, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 8&#125;B = &#123;4, 5, 6, 7, 9&#125; 执行归并的过程，i 到终点以后，j 指向7，也就是第4个元素。 这个数组中有4个逆序对。 规律很显然，当一个指针走到头时，另一个指针的位置就是逆序对的个数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int countSplitInversions(int *a, int *b, int size_a, int size_b, int *temp) &#123; int i = 0; int j = 0; int num = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt;= b[j] &amp;&amp; i != size_a || j == size_b) &#123; temp[count] = a[i++]; num += j; &#125; else if(a[i] &gt; b[j] &amp;&amp; j != size_b || i == size_a) &#123; temp[count] = b[j++]; &#125; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125; return num;&#125;int countInversions(int *a, int n, int *temp) &#123; if (n == 1) return 0; int x = countInversions(a, n / 2, temp); int y = countInversions(a + n / 2, n - n / 2, temp + n / 2); int z = countSplitInversions(a, a + n / 2, n / 2, n - n / 2, temp); return x + y + z;&#125;int main() &#123; int a[] = &#123;1, 5, 6, 4, 10, 2, 11, 22, 8, 7, 9&#125;; int *temp = (int *)malloc(sizeof(a)); int result = countInversions(a, 11, temp); printf(\"%d\\n\", result); return 0;&#125;","categories":[],"tags":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://llag9810.github.io/tags/算法笔记/"}]},{"title":"Android消息机制——Handler机制详解","slug":"Android消息机制——Handler机制详解","date":"2017-03-13T10:47:16.000Z","updated":"2017-03-24T11:25:34.276Z","comments":true,"path":"2017/03/13/Android消息机制——Handler机制详解/","link":"","permalink":"http://llag9810.github.io/2017/03/13/Android消息机制——Handler机制详解/","excerpt":"","text":"Android Handler 机制详解一些基础回顾引子 主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。 子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。 简而言之，就是说： 主线程不能执行耗时操作（避免ANR） 子线程不能直接更新UI界面 Handler 的简单使用1234567mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // TODO: implement this method. &#125;&#125;; 在新的线程中：123Message msg = Message.obtain();msg.what = 1;mHandler.sendMessage(msg); 简单的Handler使用 上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。 Handler 机制的分析理解下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。 Message简介第一步当然是创建一个消息。在创建新Message时，我们使用Message.obtain()方法来新建一条消息，而不是直接new Message()。我们不妨来看一下obtain方法的源代码 Message的源代码链接：android.os.Message源代码 12345678910111213141516/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 可见从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool == null的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 我们继续深入Message类来看。首先看一下其中几个重要的成员变量1234567891011121314151617public int what;public int arg1; public int arg2;public Object obj;Bundle data;Handler target;Runnable callback;Message next;private static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。 target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。 sPool: 消息回收池，是个链表结构。 返回去再看看obtain和recycle方法，是不是清晰多了 : ) 小结： 使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。 每个message都对应一个发送该消息的Handler。（后面详解） message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解） MessageQueue 简介MessageQueue源码 MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表） 插入（入队） enqueueMessage(Message msg, long when) 读取（出队） next() 顾名思义。这一部分源代码分析先跳过，随后分析。 Handler 简介在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。 首先当然需要new一个Handler，我们来看看Handler的构造函数和注释。12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; 无参的构造函数最终追溯到如下两个构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;/** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. Also set whether the handler * should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可见，在新建一个Handler时有两种情况。 如果没有指定looper，则构造函数会调用Looper.myLooper()方法来获得当前线程（i.e. 创建当前Handler的线程）的looper，并持有其引用。如果当前线程还没有初始化looper则会抛RuntimeException。 如果指定了looper，那么Handler就持有你指定looper的引用。 总而言之，每个Handler都对应有一个Looper。关于Looper的内容下面开始。 Looper 简介Looper源代码 我们先截取部分成员变量 12345static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue;final Thread mThread; ThreadLocal是什么 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). 下面是looper的prepare方法和其构造函数123456789101112131415161718192021222324252627282930313233 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 12345678910111213/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 也就是说，根据ThreadLocal的机理，每个线程都对应一个looper。 我们通过prepare方法创建当前线程对应的looper，也就是调用了私有的构造方法。我们注意到，当looper创建的时候会随之创建一个MessageQueue，一个Looper对应一个MessageQueue。 主线程是个例外，其looper为专门的一个成员变量 sMainLooper。主线程的Looper在Main函数中自动被创建了。 1234567891011121314151617181920212223242526272829303132333435363738394041public final class ActivityThread &#123; (前面代码省略..............) public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; &#125; 结合上面分析的Looper可以得到如下结论： 每个线程能且只能创建一个对应的looper，主线程的looper比较特殊。 在looper创建时会对应生成当前线程的MessageQueue。 也就是说，线程、looper和MessageQueue某种程度上是一一对应的关系。简单来说，我们在一条线程中执行Looper.prepare()方法时，创建了属于这条线程的Looper和MessageQueue. 一般情况我们使用无参的构造函数，实际上是把Handler和当前线程的Looper和MessageQueue“绑定”。也就是说在当前线程处理消息。 主线程是个例外，任何一个线程中的Handler都可以绑定主线程的Looper，也就是说，无论哪个线程的Handler都可以往主线程发消息。 因为Handler、Looper和Message的三角关系被我强行拆成三个部分很难理解清楚。我先把上述的结论下了。我们再回到Handler的sendMessage()方法，看看一条消息是怎么被发送的。 回到Handler和LoopersendMessage有一篮子方法，我们发现，关于send和post的方法里面，调来调去就是几个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis) &#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r) &#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 殊途同归，最后10 个方法都进入了enqueueMessage方法。1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 之前说过，每个message持有一个handler的引用，这个handler就是发送消息的handler，最后也会发回这个handler去处理消息。而发送消息的过程，就是在当前线程的MessageQueue里面enqueue一条消息。 那么，当消息被enqueue到队列之后，Looper是怎么样轮询消息的呢？ Looper有个重要的方法是loop，之前只是简单介绍了looper，但并没有把方法贴出来。现在我们来看看Looper.loop()这一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 之前说过，每个message持有一个发送这个消息的handler的引用(target)。 在处理消息时，直接调用了msg.target.dispatchMessage()方法，把消息送回Handler进行处理。 结合之前的内容，再总结一下： Handler发送消息仅仅是调用MessageQueue的enqueueMessage向插入一条信息到MessageQueue Looper不断轮询调用MessageQueue的next方法获得下一条待处理的消息 如果发现message就调用handler的dispatchMessage，ldispatchMessage被成功调用，接着调用handlerMessage() 发送消息的过程已经非常明确了。下面我们来看处理消息的过程。123456789101112131415161718192021/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125;/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; message对象中有一个callback成员变量，如果这个message有callback那么就按照callback的内容去处理。否则就调用正常的handleMessage方法。 题外话除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作： Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 post方法和sendMessage方法使用类似，只是post的参数是一个Runnable。我们来看看源代码1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 很明显，是通过getPostMessage把runnable包装成了一个Message。然后再去发一条message。我们看看这个包装消息的方法12345private final Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; 在这个方法中将消息的callback字段的值指定为传入的Runnable对象。咦？这个callback字段看起来有些眼熟啊，喔！在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法。 那我们快来看下handleCallback()方法中的代码吧：123private final void handleCallback(Message message) &#123; message.callback.run(); &#125; 竟然就是直接调用了一开始传入的Runnable对象的run()方法。 然后再来看一下View中的post()方法，post方法也是传入一个runnable。源码如下所示：12345678910public boolean post(Runnable action) &#123; Handler handler; if (mAttachInfo != null) &#123; handler = mAttachInfo.mHandler; &#125; else &#123; ViewRoot.getRunQueue().post(action); return true; &#125; return handler.post(action); &#125; 原来就是调用了Handler中的post()方法，我相信已经没有什么必要再做解释了。 最后再来看一下Activity中的runOnUiThread()方法，代码如下所示：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。还有什么会比这更清晰明了的吗？ 通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助Handler机制来实现。 总结Handler机制简单概括如下： 每个线程可以初始化一个looper和MessageQueue，主线程在ActivityThread运行时已经有了。 Handler负责发送消息对象，发送时会把消息对象里面的target指向自己，表明“消息是我发的”。 Handler发送消息的过程就是往MessageQueue里面入队的过程。入的是哪个队取决于你的Handler，如果new的时候构造函数为空，那就是当前线程的MessageQueue。之前说了主线程的looper可以在任何地方获得（单独的成员变量），所以任何线程的Handler都可以往主线程的MessageQueue中发消息。 Looper负责轮询消息，每拿到一个消息会根据它的target丢给发消息的那个Handler，调用其dispatchMessage方法去处理。 下图盗网上的，自己画不好。顺便求一波Windows和Linux上画这种流程图的工具。 先写那么多，有问题以后再改…… Handler机制过程图","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://llag9810.github.io/tags/Android/"}]}]}