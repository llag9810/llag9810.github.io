{"meta":{"title":"萌妹子的小窝","subtitle":"Android学习中/想学算法/游走在挂科边缘","description":"Android learner","author":"yifan","url":"http://llag9810.github.io"},"pages":[{"title":"tags","date":"2017-03-13T07:13:51.000Z","updated":"2017-03-13T07:13:51.367Z","comments":true,"path":"tags/index.html","permalink":"http://llag9810.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android消息机制——Handler机制详解","slug":"Android消息机制——Handler机制详解","date":"2017-03-13T10:47:16.000Z","updated":"2017-03-14T07:24:09.000Z","comments":true,"path":"2017/03/13/Android消息机制——Handler机制详解/","link":"","permalink":"http://llag9810.github.io/2017/03/13/Android消息机制——Handler机制详解/","excerpt":"","text":"Android Handler 机制详解一些基础回顾引子一个程序的运行，就是一个进程的在执行，一个进程里面可以拥有很多个线程。 主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。 子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。 简而言之，就是说： 主线程不能执行耗时操作（避免ANR） 子线程不能直接更新UI界面 Handler 的简单使用1234567mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // TODO: implement this method. &#125;&#125;; 在新的线程中：123Message msg = Message.obtain();msg.what = 1;mHandler.sendMessage(msg); example 上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。 Handler 机制的分析理解下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。 Message第一步当然是创建一个消息。在创建新Message时，我们使用Message.obtain()方法来新建一条消息，而不是直接new Message()。我们不妨来看一下obtain方法的源代码 Message的源代码链接：android.os.Message源代码 12345678910111213141516/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 可见从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool == null的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 我们继续深入Message类来看。首先看一下其中几个重要的成员变量1234567891011121314151617public int what;public int arg1; public int arg2;public Object obj;Bundle data;Handler target;Runnable callback;Message next;private static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。 target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。 sPool: 消息回收池，是个链表结构。 返回去再看看obtain和recycle方法，是不是清晰多了 : ) 小结： 使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。 每个message都对应一个发送该消息的Handler。（后面详解） message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解） MessageQueueMessageQueue源码 MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表） 插入（入队） enqueueMessage(Message msg, long when) 读取（出队） next() 顾名思义。这一部分源代码分析先跳过，随后分析。 Handler在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。 首先当然需要new一个Handler，我们来看看Handler的构造函数和注释。12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; 无参的构造函数最终追溯到如下两个构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;/** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. Also set whether the handler * should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可见，在新建一个Handler时有两种情况。 如果没有指定looper，则构造函数会调用Looper.myLooper()方法来获得当前线程（i.e. 创建当前Handler的线程）的looper，并持有其引用。如果当前线程还没有初始化looper则会抛RuntimeException。 如果指定了looper，那么Handler就持有你指定looper的引用。 总而言之，每个Handler都对应有一个Looper。关于Looper的内容下面开始。 LooperLooper源代码 我们先截取部分成员变量 12345static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue;final Thread mThread; ThreadLocal是什么 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). 下面是looper的parpare方法和其构造函数123456789101112131415161718192021222324252627282930313233 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 12345678910111213/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125;","categories":[],"tags":[]}]}