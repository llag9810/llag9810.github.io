{"meta":{"title":"小窝","subtitle":"Android/Java/随便写写","description":"Android learner","author":"yifan","url":"http://llag9810.github.io"},"pages":[{"title":"tags","date":"2017-03-13T07:13:51.000Z","updated":"2017-03-24T11:26:56.847Z","comments":true,"path":"tags/index.html","permalink":"http://llag9810.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 虚拟机读书笔记（二）","slug":"Java-虚拟机读书笔记（二）","date":"2018-02-04T15:13:35.000Z","updated":"2018-02-04T15:55:42.811Z","comments":true,"path":"2018/02/04/Java-虚拟机读书笔记（二）/","link":"","permalink":"http://llag9810.github.io/2018/02/04/Java-虚拟机读书笔记（二）/","excerpt":"","text":"概述这篇博客对应博客对应的是《深入理解 Java 虚拟机》第三章的部分内容。包括 GC 的简单介绍、判断对象存活的方法、强软弱虚四种引用，还有finalize()方法的简介。有关垃圾回收算法的部分在下篇中填坑。 GC 简介说起垃圾回收(Garbage Collection,GC),大部分人都把这项技术当做Java语言的伴生产物。事实上,GC 的历史比 Java 久远,1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言。当 Lisp 还在胚胎时时,人们就在思考 GC 需要完成的3件事情: 哪些内存需要回收? 什么时候回收? 如何回收? 回到我们熟悉的 Java 语言，不妨回顾Java内存运行时区域的各个部分。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由JIT编译器进行一些优化,但在本章基于概念模型的讨论中,大体上可以认为是编译期可知的。)因此这几个区域的内存分配和回收都具备确定性,在这几个区域内就不需要过多考虑回收的问题。因为方法结束或者线程结束时,内存自然就跟随着回收了。 而 Java 堆和方法区则不一样,一个接口中的多个实现类需要的内存可能不一样,一个方法中的多个分支需要的内存也可能不一样,我们只有在程序处于运行期间时才能知道会创建哪些对象,这部分内存的分配和回收都是动态的。 所以垃圾收集器所关注的是这部分（堆和方法区）内存。 判断对象是否“存活”在堆里面存放着 Java 世界中几乎所有的对象实例垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。 下面简要介绍两种判断对象存活的算法:引用计数和可达性分析。 引用计数引用计数是一种简单的判断对象存活的算法。其算法是这样的： 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1 ；每当有一个引用失效时，计数器值就减 1 。 任何时刻计数器为 0 的对象就是不可能再被使用的对象，即可以被回收的对象。 客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是,至少主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 举个简单的例子，见下面代码中的testGC()方法：对象 objA 和 objB 都有成员变量instance，令objA.instance = objB及objB.instance = objA。除此之外,这两个对象再无任何引用。也就是说实际上这两个对象已经不可能再被访问。 但是，它们因为互相引用着对方，导致它们的引用计数都为1，于是引用计数算法无法通知 GC 收集器回收它们。 （下面代码摘抄自《深入理解 Java 虚拟机》第二版 3.2.1 章节）12345678910111213141516171819202122/***testGC()方法执行后,objA和objB会不会被GC呢?*@author zzm*/public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024*1024; /** *这个成员属性的唯一意义就是占点内存,以便能在GC日志中看清楚是否被回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; //假设在这行发生GC,objA和objB是否能被回收? System.gc(); &#125;&#125; 运行结果（摘抄自书籍）：1234567891011[FullGC(System)[Tenured:0K-&gt;210K(10240K),0.0149142secs]4603K-&gt;210K(19456K),[Perm:2999K-&gt;2999K(21248K)],0.0150007 secs][Times:user=0.01 sys=0.00,real=0.02 secs]Heapdef new generation total 9216K,used 82K[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Eden space 8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)from space 1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)to space 1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)tenured generation total 10240K,used 210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)the space 10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)compacting perm gen total 21248K,used 3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)the space 21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)No shared spaces configured. 很显然，日志中的”4603k -&gt; 210k”说明这两个对象成功的被回收。这也从侧面说明了虚拟机并不是通过引用计数来实现垃圾回收的。 可达性分析在目前的主流语言中，基本上都是通过可达性分析(Reachability Analysis)来判定对象的存活与否。 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。 如下图所示，对象object 5、object 6、object 7虽然互相有关联,但是它们到GC Roots是不可达的,所以它们将会被判定为是可回收的对象。 可达性分析判断回收 在Java中，作为 GC root 的引用一般包括： 栈(栈帧中的局部变量)中引用的对象。 方法区中类静态成员变量引用的对象。 方法区中常量引用的对象。 native 方法栈中 JNI（Native 方法）引用的对象。 #","categories":[],"tags":[]},{"title":"ArrayList 源码解析","slug":"ArrayList-源码解析","date":"2017-09-03T04:41:55.000Z","updated":"2018-02-03T05:21:39.116Z","comments":true,"path":"2017/09/03/ArrayList-源码解析/","link":"","permalink":"http://llag9810.github.io/2017/09/03/ArrayList-源码解析/","excerpt":"","text":"ArrayList 简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 实现了 RandmoAccess 接口，即提供了随机访问功能。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过 Iterator 迭代器访问”的效率。 ArrayList 实现了 Cloneable 接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。 下面让我们翻开 ArrayList 的源代码，看看一些常用的方法属性，以及一些需要注意的地方。 ArrayList 属性ArrayList 属性主要就是当前数组长度size，以及存放数组的对象 elementData 数组，除此之外还有一个经常用到的属性就是从 AbstractList 继承过来的 modCount 属性，代表ArrayList集合的修改次数。关于modCount的作用后面讲到。 123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123; // 序列化id private static final long serialVersionUID = 8683452581122892189L; // 默认初始的容量 private static final int DEFAULT_CAPACITY = 10; // 一个空对象 private static final Object[] EMPTY_ELEMENTDATA = new Object[0]; // 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0]; // 当前数据对象存放地方，当前对象不参与序列化 transient Object[] elementData; // 当前数组长度 private int size; // 数组最大长度 private static final int MAX_ARRAY_SIZE = 2147483639; // 省略方法&#125; ArrayList 构造函数默认构造函数（空参数）也就是我们最常用的不带参数的构造，如果不传入参数，则使用默认无参构建方法创建ArrayList对象，如下：123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 注意：此时我们创建的ArrayList对象中的 elementData 中的长度是1，size 是 0 ,当进行第一次add的时候，elementData 将会变成默认的长度：10。 接受一个 int 参数构造函数如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; 接受一个 Collection 的构造在构造一个 ArrayList 时，可以直接传入一个Collection，将已有的集合构造为一个 List。构造过程可以概括为： (1) 将collection对象转换成数组，然后将数组的地址的赋给elementData。 (2) 更新size的值，同时判断size的大小，如果是size等于0，直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData (3) 如果size的值大于0，则执行Arrays.copy方法，把 collection 对象的内容（可以理解为深拷贝）copy到elementData中。 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; add 方法add 的方法有两个，一个是带一个参数的，一个是带两个参数的，下面我们一个个讲解。 一个参数的 addadd(E e) 方法主要的执行逻辑如下： 1）确保数组已使用长度（size）加1之后足够存下 下一个数据 2）修改次数modCount 标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组，grow方法会将当前数组的长度变为原来容量的1.5倍。 3）确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 4）返回添加成功布尔值。 123456public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 确保添加的元素有地方存储，当第一次添加元素的时候this.size+1 的值是1，所以第一次添加的时候会将当前elementData数组的长度变为10：1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 将修改次数（modCount）自增1，判断是否需要扩充数组长度,判断条件就是用当前所需的数组最小长度与数组的长度对比，如果大于0，则增长数组长度。1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 如果当前的数组已使用空间（size）加1之后 大于数组长度，则增大数组容量，扩大为原来的1.5倍。12345678910111213private void grow(int arg0) &#123; int arg1 = this.elementData.length; int arg2 = arg1 + (arg1 &gt;&gt; 1); if (arg2 - arg0 &lt; 0) &#123; arg2 = arg0; &#125; if (arg2 - 2147483639 &gt; 0) &#123; arg2 = hugeCapacity(arg0); &#125; this.elementData = Arrays.copyOf(this.elementData, arg2); &#125; 两个参数的 addadd(int index, E element)方法其实和上面的add类似，该方法可以按照元素的位置，指定位置插入元素，具体的执行逻辑如下： 1）确保数插入的位置小于等于当前数组长度，并且不小于0，否则抛出异常 2）确保数组已使用长度（size）加1之后足够存下 下一个数据 3）修改次数（modCount）标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组 4）grow方法会将当前数组的长度变为原来容量的1.5倍。 5）确保有足够的容量之后，使用System.arraycopy 将需要插入的位置（index）后面的元素统统往后移动一位。 6）将新的数据内容存放到数组的指定位置（index）上。123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 注意：使用该方法的话将导致指定位置后面的数组元素全部重新移动，即往后移动一位。 get 方法返回指定位置元素。不多讲12345public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; set方法确保set的位置小于当前数组的长度（size）并且大于0，获取指定位置（index）元素，然后放到 oldValue 存放，将需要设置的元素放到指定的位置（index）上，然后将原来位置上的元素 oldValue 返回给用户。1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; contains方法调用 indexOf 方法，遍历数组中的每一个元素作对比，如果找到对于的元素，则返回 true，没有找到则返回 false。 123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; remove方法根据 index 下标 remove1）判断下标有没有越界 2）自增 modCount 3）将指定位置（index）上的元素保存到 oldValue 4）将指定位置（index）上的元素都往前移动一位 5）将最后面的一个元素置空，好让垃圾回收器回收 6）将原来的值 oldValue 返回 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 注意：调用这个方法不会缩减数组的长度，只是将最后一个数组元素置空而已。 根据对象remove循环遍历所有对象，得到对象所在索引位置，然后调用fastRemove方法，执行remove操作 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 定位到需要remove的元素索引，先将index后面的元素往前面移动一位（调用System.arrayCopy实现），然后将最后一个元素置空。12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; trimToSize方法1）modCount 加1 2）将 elementData 中空余的空间（包括null值）去除，例如：数组长度为10，其中只有前三个元素有值，其他为空，那么调用该方法之后，数组的长度变为3。12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; iteratoriterator 方法返回的是一个内部类，由于内部类的创建默认含有外部的 this指针，所以这个内部类可以调用到外部类的属性。123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 一般的话，调用完iterator()之后，我们会使用迭代器做遍历，这里使用next做遍历的时候有个需要注意的地方，就是调用next的时候，可能会引发ConcurrentModificationException，当修改次数，与期望的修改次数（调用iterator方法时候的修改次数）不一致的时候，会发生该异常，详细我们看一下代码实现：123456789101112@SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; expectedModCount 这个值是在用户调用 ArrayList 的 iterator 方法时候确定的，但是在这之后用户 add ，或者 remove 了 ArrayList 的元素，那么 modCount 就会改变，那么这个值就会不相等，将会引发 ConcurrentModificationException 异常，这个是在多线程使用情况下，比较常见的一个异常。1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 小结ArrayList还有以下一些特点： ArrayList自己实现了序列化和反序列化的方法，因为它自己实现了 private void writeObject(java.io.ObjectOutputStream s)和 private void readObject(java.io.ObjectInputStream s)方法 ArrayList基于数组方式实现，无容量的限制（数组填满时会扩容至原容量的1.5倍） 删除元素时不会减少容量（若希望减少容量，trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。 线程不安全 add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位 get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)） remove(Object o)需要遍历数组 remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高 contains(E)需要遍历数组 使用iterator遍历时不能做修改，否则会引发多线程异常","categories":[],"tags":[]},{"title":"Java 虚拟机（一）","slug":"Java-虚拟机（一）","date":"2017-06-21T10:57:08.000Z","updated":"2018-02-04T15:16:31.000Z","comments":true,"path":"2017/06/21/Java-虚拟机（一）/","link":"","permalink":"http://llag9810.github.io/2017/06/21/Java-虚拟机（一）/","excerpt":"","text":"这部分博客对应的是《深入理解 Java 虚拟机》第二章的部分内容，关于 OOM 异常的部分后面再填坑。 运行时数据区 Runtime Data AreaJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据Java虚拟机规范的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示。 Runtime data area 单个线程内共享的区： PC Register 寄存器 JVM Stack 虚拟机栈 Native Method Stack 本地方法栈 所有线程共享的区： Heap 堆 Method Area 方法区，including Runtime Constant Pool 常量池 PC Register程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值是未定义的。 JVM Stack每个线程对应一个Java虚拟机栈。在线程创建时同时创建。用于存储栈帧。JVM栈和一般语言，比如 C 语言的栈类似：它存储局部变量和与一些尚未算好的结果，在方法调用和返回时起到很重要作用。因为除了栈帧的出栈和入栈之外，Java 虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。Java 虚拟机栈所使用的内存不需要保证是连续的。 （请注意避免混淆 Stack、Heap 和 Java Stack、Java Heap 的概念，Java 虚拟机的实现本质上是由其他语言所编写的应用程序，Java 语言程序里分配在 Java Stack 中的数据，从实现虚拟机的程序角度上看则可能分配在 Heap 之中） native stackJava 虚拟机实现可能会使用到传统的栈（通常称为 C stack）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（native method stack）。当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也可以使用本地方法栈。如果 Java 虚拟机不支持 native 方法，或是本身不依赖传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。Java 虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。 Java HeapJava 虚拟机中，堆（heap）是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（automatic storage management system，也就是常说的 garbage collector（GC, 垃圾收集器））所管理的各种对象。 方法区在 Java 虚拟机中，方法区（method area）是可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区（storage area for compiled code）或者操作系统进程的正文段（text segment）的作用非常类似，它存储了每一个类的结构信息，例如，运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。这个版本的 Java 虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。 Java堆栈示意图 Class 文件简介概述class文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活，它甚至比Java源文件有着更强的描述能力。 class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。 class文件 class文件结构 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count 魔数、版本号magic在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： 0XCAFEBABE 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别。 minor_version 和 major_version紧接着魔数的四个字节是class文件的此版本号和主版本号。 随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。 常量池在class文件中， 位于版本号后面的就是常量池相关的数据项。 常量池是class文件中的一项非常重要的数据。 常量池中存放了文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符， 对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的this_class, super_class, field_info, attribute_info等， 另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。 此外， 常量池中各个项也会相互引用。","categories":[],"tags":[{"name":"Java,虚拟机","slug":"Java-虚拟机","permalink":"http://llag9810.github.io/tags/Java-虚拟机/"}]},{"title":"Stanford Algorithms Divide and Conquer笔记","slug":"Stanford-Algorithms-Divide-and-Conquer笔记1","date":"2017-03-26T15:35:53.000Z","updated":"2017-05-13T08:37:45.006Z","comments":true,"path":"2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","link":"","permalink":"http://llag9810.github.io/2017/03/26/Stanford-Algorithms-Divide-and-Conquer笔记1/","excerpt":"","text":"斯坦福算法课踩坑系列 S01E01写在正题前还没开始学算法，数据结构也是半吊子。脑抽在 Coursera 上面跟了这门课，上了几节后听别人说另外一门 Prinston 的讲得更接地气，少了很多数学证明，也多了很多实现细节。总之，已经买了也不能中途弃坑。所以自己打算写个长期系列。 言归正传，这门课主要分为以下四个部分： Divide and Conquer, Sorting and Searching, and Randomized Algorithms. Graph Search, Shortest Paths, and Data Structures. Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming. Shortest Paths Revisited, NP-Complete Problems and What To Do About Them. 目前我上完了第一部分，也就是分治、排序、搜索和随机算法。 第一集先整理这两个部分：归并排序、寻找逆序对。 归并排序(Merge Sort) 一图流，不展开讲 这个没什么可以记笔记的。顾名思义，归并排序分为两步。第一，递归的把数组二分；第二，一层一层的把已经排序的两个小数组进行合并。 伪代码大致如下：12345678void mergeSort(int a[], int n) &#123; if (n == 1) return; mergeSort(a, n / 2); mergeSort(a + n / 2, n / 2); merge(a, a + n / 2, n / 2, n - n / 2);&#125; 其中，前两步分治为两个子问题，最后一步是进行归并。合并的过程也很简单。由于两个子数组已经排好序，所以同时对两个数组，两个指针进行一次遍历即可。自己随手实现了下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void merge(int a[], int b[], int size_a, int size_b, int temp[]) &#123; int i = 0; int j = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt; b[j] &amp;&amp; i &lt; size_a || j == size_b) temp[count] = a[i++]; else if (a[i] &gt;= b[j] &amp;&amp; j &lt; size_b || i == size_a) temp[count] = b[j++]; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125;&#125;void mergeSort(int* a, int n, int* temp) &#123; if (n == 1) return; mergeSort(a, n / 2, temp); mergeSort(a + n / 2, n - n / 2, temp + n / 2); merge(a, a + n / 2, n / 2, n - n / 2, temp);&#125;int main() &#123; int a[] = &#123;3, 5, 8, 6, 7, 4, 2, 1&#125;; int *temp = (int *)malloc(sizeof(a)); mergeSort(a, 8, temp); for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) &#123; printf(\"%d \", temp[i]); &#125; return 0;&#125; 寻找逆序对(Counting Inversions)要求： Input : array A containing the numbers 1,2,3,..,n in some arbitrary order. Output : number of inversions = number of pairs(i,j) of array indices with i &lt; j and A[i] &gt; A[j]. 分析：要求的逆序对可以分为三种情况。 情况1：i, j都在数组的前半边。 情况2：i, j都在数组的后半边。 情况3：i, j分别位于数组的前、后半边。 对于前两种情况，直接递归即可，然后加上第三种情况的结果即为所求。 伪代码如下：12345678count(array A, length n) if n = 1, return 0; x = count(half of A, n / 2); y = count(2nd half of A, n / 2); z = countSplitInversion(A, n); // Not implemented yet return x + y + z; Goal : implement CountSplitInversions in linear (O(n)) time then count will run in O(nlog(n)) time. 寻找 split inversion 的过程和归并排序的合并过程类似。我们不妨看几个例子： 假如数组中不存在 Split Inversions 比如：A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 4&#125;B = &#123;5, 6, 7, 8, 9&#125; 也就是说，前半个数组中所有的元素都比后半个数组小。对该数组进行归并，使用 i, j 两指针。此时，当 i 走到头时，j 尚未移动。 假如数组中存在 m 个 Split Inversions 比如：A = {0, 1, 2, 3, 8, 4, 5, 6, 7, 9} 进行分治后， 12A = &#123;0, 1, 2, 3, 8&#125;B = &#123;4, 5, 6, 7, 9&#125; 执行归并的过程，i 到终点以后，j 指向7，也就是第4个元素。 这个数组中有4个逆序对。 规律很显然，当一个指针走到头时，另一个指针的位置就是逆序对的个数。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int countSplitInversions(int *a, int *b, int size_a, int size_b, int *temp) &#123; int i = 0; int j = 0; int num = 0; for (int count = 0; count &lt; size_a + size_b; count++) &#123; if (a[i] &lt;= b[j] &amp;&amp; i != size_a || j == size_b) &#123; temp[count] = a[i++]; num += j; &#125; else if(a[i] &gt; b[j] &amp;&amp; j != size_b || i == size_a) &#123; temp[count] = b[j++]; &#125; &#125; for (int count = 0; count &lt; size_a + size_b; count++) &#123; a[count] = temp[count]; &#125; return num;&#125;int countInversions(int *a, int n, int *temp) &#123; if (n == 1) return 0; int x = countInversions(a, n / 2, temp); int y = countInversions(a + n / 2, n - n / 2, temp + n / 2); int z = countSplitInversions(a, a + n / 2, n / 2, n - n / 2, temp); return x + y + z;&#125;int main() &#123; int a[] = &#123;1, 5, 6, 4, 10, 2, 11, 22, 8, 7, 9&#125;; int *temp = (int *)malloc(sizeof(a)); int result = countInversions(a, 11, temp); printf(\"%d\\n\", result); return 0;&#125;","categories":[],"tags":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://llag9810.github.io/tags/算法笔记/"}]},{"title":"Android消息机制——Handler机制详解","slug":"Android消息机制——Handler机制详解","date":"2017-03-13T10:47:16.000Z","updated":"2017-03-24T11:25:34.276Z","comments":true,"path":"2017/03/13/Android消息机制——Handler机制详解/","link":"","permalink":"http://llag9810.github.io/2017/03/13/Android消息机制——Handler机制详解/","excerpt":"","text":"Android Handler 机制详解一些基础回顾引子 主线程：也叫UI线程，或称ActivityThread，用于运行四大组件和处理他们用户的交互。 ActivityThread管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，在Android系统中，在默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的主线程负责执行。ActivityThread既要处理Activity组件的UI事件，又要处理Service后台服务工作，通常会忙不过来。为了解决此问题，主线程可以创建多个子线程来处理后台服务工作，而本身专心处理UI画面的事件。 子线程： 用于执行耗时操作，比如 I/O操作和网络请求等。（安卓3.0以后要求耗访问网络必须在子线程种执行）更新UI的工作必须交给主线程，子线程在安卓里是不允许更新UI的。 简而言之，就是说： 主线程不能执行耗时操作（避免ANR） 子线程不能直接更新UI界面 Handler 的简单使用1234567mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // TODO: implement this method. &#125;&#125;; 在新的线程中：123Message msg = Message.obtain();msg.what = 1;mHandler.sendMessage(msg); 简单的Handler使用 上述代码和图片介绍了handler最简单的一种使用方法和过程，下面我们按过程详细介绍handler机制。 Handler 机制的分析理解下面，我们按照消息从创建、发送到处理的过程，结合源代码理解Handler机制。 Message简介第一步当然是创建一个消息。在创建新Message时，我们使用Message.obtain()方法来新建一条消息，而不是直接new Message()。我们不妨来看一下obtain方法的源代码 Message的源代码链接：android.os.Message源代码 12345678910111213141516/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message(); &#125; 可见从obtain()的源代码中我们可以知道,它是静态方法,而且只有在spool == null的情况下才会new出一个Message(),返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。 说到回收，我们看看跟回收有关的方法。最后追溯到recycleUnchecked()方法。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 我们继续深入Message类来看。首先看一下其中几个重要的成员变量1234567891011121314151617public int what;public int arg1; public int arg2;public Object obj;Bundle data;Handler target;Runnable callback;Message next;private static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50; 其中，前五个不再赘述。其中what用于识别(identify)消息。后面四个都是msg对象中携带的数据(data)。 target指的是发送这条消息的Handler，在发送消息时，这个msg对象会持有一个对Handler的引用。这个后面分析Handler源码时细说。callback是实现了Runnable接口，当这个msg对象的callback不为null时，在分发Message时会回调这个callback，否则执行handleMessage()方法。这个后面分析时会再次细说。 sPool: 消息回收池，是个链表结构。 返回去再看看obtain和recycle方法，是不是清晰多了 : ) 小结： 使用message.obtain()方法新建message对象，message是重复使用的，有对象池进行回收。 每个message都对应一个发送该消息的Handler。（后面详解） message在被处理时会先回调message对象持有的callback，在callback为null的时候才会调用handler的handleMessage方法。（后面详解） MessageQueue 简介MessageQueue源码 MessageQueue中文翻译就是消息队列，它内部存储了一组信息，存放的是Message，以队列的形式对外提供了插入和删除的工作（虽然名字叫做队列，但是其内部的 存储结构是单链表） 插入（入队） enqueueMessage(Message msg, long when) 读取（出队） next() 顾名思义。这一部分源代码分析先跳过，随后分析。 Handler 简介在消息创建完毕后，我们需要使用Handler的sendMessage方法发送消息。 首先当然需要new一个Handler，我们来看看Handler的构造函数和注释。12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; 无参的构造函数最终追溯到如下两个构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;/** * Use the provided &#123;@link Looper&#125; instead of the default one and take a callback * interface in which to handle messages. Also set whether the handler * should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param looper The looper, must not be null. * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可见，在新建一个Handler时有两种情况。 如果没有指定looper，则构造函数会调用Looper.myLooper()方法来获得当前线程（i.e. 创建当前Handler的线程）的looper，并持有其引用。如果当前线程还没有初始化looper则会抛RuntimeException。 如果指定了looper，那么Handler就持有你指定looper的引用。 总而言之，每个Handler都对应有一个Looper。关于Looper的内容下面开始。 Looper 简介Looper源代码 我们先截取部分成员变量 12345static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue;final Thread mThread; ThreadLocal是什么 This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). 下面是looper的prepare方法和其构造函数123456789101112131415161718192021222324252627282930313233 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 12345678910111213/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 也就是说，根据ThreadLocal的机理，每个线程都对应一个looper。 我们通过prepare方法创建当前线程对应的looper，也就是调用了私有的构造方法。我们注意到，当looper创建的时候会随之创建一个MessageQueue，一个Looper对应一个MessageQueue。 主线程是个例外，其looper为专门的一个成员变量 sMainLooper。主线程的Looper在Main函数中自动被创建了。 1234567891011121314151617181920212223242526272829303132333435363738394041public final class ActivityThread &#123; (前面代码省略..............) public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; &#125; 结合上面分析的Looper可以得到如下结论： 每个线程能且只能创建一个对应的looper，主线程的looper比较特殊。 在looper创建时会对应生成当前线程的MessageQueue。 也就是说，线程、looper和MessageQueue某种程度上是一一对应的关系。简单来说，我们在一条线程中执行Looper.prepare()方法时，创建了属于这条线程的Looper和MessageQueue. 一般情况我们使用无参的构造函数，实际上是把Handler和当前线程的Looper和MessageQueue“绑定”。也就是说在当前线程处理消息。 主线程是个例外，任何一个线程中的Handler都可以绑定主线程的Looper，也就是说，无论哪个线程的Handler都可以往主线程发消息。 因为Handler、Looper和Message的三角关系被我强行拆成三个部分很难理解清楚。我先把上述的结论下了。我们再回到Handler的sendMessage()方法，看看一条消息是怎么被发送的。 回到Handler和LoopersendMessage有一篮子方法，我们发现，关于send和post的方法里面，调来调去就是几个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis) &#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postAtFrontOfQueue(Runnable r) &#123; return sendMessageAtFrontOfQueue(getPostMessage(r));&#125;public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 殊途同归，最后10 个方法都进入了enqueueMessage方法。1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 之前说过，每个message持有一个handler的引用，这个handler就是发送消息的handler，最后也会发回这个handler去处理消息。而发送消息的过程，就是在当前线程的MessageQueue里面enqueue一条消息。 那么，当消息被enqueue到队列之后，Looper是怎么样轮询消息的呢？ Looper有个重要的方法是loop，之前只是简单介绍了looper，但并没有把方法贴出来。现在我们来看看Looper.loop()这一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 之前说过，每个message持有一个发送这个消息的handler的引用(target)。 在处理消息时，直接调用了msg.target.dispatchMessage()方法，把消息送回Handler进行处理。 结合之前的内容，再总结一下： Handler发送消息仅仅是调用MessageQueue的enqueueMessage向插入一条信息到MessageQueue Looper不断轮询调用MessageQueue的next方法获得下一条待处理的消息 如果发现message就调用handler的dispatchMessage，ldispatchMessage被成功调用，接着调用handlerMessage() 发送消息的过程已经非常明确了。下面我们来看处理消息的过程。123456789101112131415161718192021/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125;/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; message对象中有一个callback成员变量，如果这个message有callback那么就按照callback的内容去处理。否则就调用正常的handleMessage方法。 题外话除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作： Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 post方法和sendMessage方法使用类似，只是post的参数是一个Runnable。我们来看看源代码1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 很明显，是通过getPostMessage把runnable包装成了一个Message。然后再去发一条message。我们看看这个包装消息的方法12345private final Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; 在这个方法中将消息的callback字段的值指定为传入的Runnable对象。咦？这个callback字段看起来有些眼熟啊，喔！在Handler的dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法。 那我们快来看下handleCallback()方法中的代码吧：123private final void handleCallback(Message message) &#123; message.callback.run(); &#125; 竟然就是直接调用了一开始传入的Runnable对象的run()方法。 然后再来看一下View中的post()方法，post方法也是传入一个runnable。源码如下所示：12345678910public boolean post(Runnable action) &#123; Handler handler; if (mAttachInfo != null) &#123; handler = mAttachInfo.mHandler; &#125; else &#123; ViewRoot.getRunQueue().post(action); return true; &#125; return handler.post(action); &#125; 原来就是调用了Handler中的post()方法，我相信已经没有什么必要再做解释了。 最后再来看一下Activity中的runOnUiThread()方法，代码如下所示：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。还有什么会比这更清晰明了的吗？ 通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助Handler机制来实现。 总结Handler机制简单概括如下： 每个线程可以初始化一个looper和MessageQueue，主线程在ActivityThread运行时已经有了。 Handler负责发送消息对象，发送时会把消息对象里面的target指向自己，表明“消息是我发的”。 Handler发送消息的过程就是往MessageQueue里面入队的过程。入的是哪个队取决于你的Handler，如果new的时候构造函数为空，那就是当前线程的MessageQueue。之前说了主线程的looper可以在任何地方获得（单独的成员变量），所以任何线程的Handler都可以往主线程的MessageQueue中发消息。 Looper负责轮询消息，每拿到一个消息会根据它的target丢给发消息的那个Handler，调用其dispatchMessage方法去处理。 下图盗网上的，自己画不好。顺便求一波Windows和Linux上画这种流程图的工具。 先写那么多，有问题以后再改…… Handler机制过程图","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://llag9810.github.io/tags/Android/"}]}]}