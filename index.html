<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://llag9810.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://llag9810.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Hello-2020-2019流水账" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/02/Hello-2020-2019%E6%B5%81%E6%B0%B4%E8%B4%A6/" class="article-date">
  <time datetime="2020-02-02T13:36:23.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/02/Hello-2020-2019%E6%B5%81%E6%B0%B4%E8%B4%A6/">Hello 2020 &amp; 2019 流水账</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻了翻之前的博客和手机，发现自己一年前（整个 2018 年）都没有好好做个总结。仔细想想，也是。从 2018 年开春自己下定决心备战春招，到大学毕业前夕的这段时间内，一切发展都出奇的顺利。像是一个没有经历过风狂雨骤的小池塘，自己就这样一天一天的摸鱼过去了……想了想这可是 3/8 的大学时光。<del>可能有记忆的也就是三件小事。一是和自己喜欢的女生在一起了。二是第一次经历了一个人在外漂泊的生活，三是连续肝了 160 小时塞尔达荒野之息</del></p>
<p>相比之下 2019 年自己经历的更多，也完成了自己社会身份的转变。无论如何都是需要记录下来的。但是人懒不想好好构思博客的结构，那就按时间顺序记个流水账吧。</p>
<p>按理说这种文章应该在 2020 年的第一天之前完成，但是想想元旦当天自己还在为新年活动值班，就只能借着春节假期写一篇迟到的文章了。</p>
<h1 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h1><p>对很多同学来说软院的毕业设计（<del>专业实训4.0</del>）可能就是毕业前的最后一波摸鱼。对我而言，我恰好找到了与之前腾讯实习期间工作相关的题目（<del>当然还有就是曙光女神放羊不管事</del>）。从一个网络数据包开始，凭借着拙劣的 C++ 水平一步一步还原出 RTP 协议，然后提取出其中的音视频码流。借此机会刚好算是把我在鹅厂实习期间学到的理论知识实践了一遍。毕设当中有个环节是要求翻译一篇外文文献，顺带着把鹅厂实习期间看过的一篇 WebRTC 拥塞控制算法的文章翻译了。</p>
<p>整个毕设过程和前年的实习经历如此密切，导致那段时间里自己不断回忆着深圳那段短暂的实习时光。在翻译那篇拥塞控制算法的时候，想起了当时我们为了改进弱网下的视频质量做的一些事情：对算法里的每个细节不断调整；通过暴力抓包去猜测竞品的数据包结构，看带宽占用去反推竞品的流控策略；因为公司的 AP 性能过好，弱网环境模拟不到位，组里买了七八个网红路由器实机测试（<del>很符合现东家“追求极致”的价值观</del>）。</p>
<p>当然啦，作为一个码农（<del>软件工程师</del>），有必要从技术角度总结下做毕设期间的收获</p>
<ul>
<li>系统入门了一遍 C++，from scratch</li>
<li>弥补了软院计算机网络开卷考试的技术债</li>
<li>把实习期间的一些理论知识实践了一遍，在音视频方面的知识有所积累</li>
</ul>
<h1 id="踏入职场"><a href="#踏入职场" class="headerlink" title="踏入职场"></a>踏入职场</h1><p>第一份工作经历和实习期间的经历差别还是非常大的。毕竟 2B 和 2C 产品的部门结构，人员安排和开发流程等都是不太一样的。</p>
<p>现在的部门是一个业务迭代飞快的部门。由于人手紧缺，自己一上来就被分了一个很大的需求。中途还经历了服务端离职换人等等一系列事情，可谓一波三折。当然最后磕磕绊绊还是按期完成，没有 delay，也没有出现线上 bug，算是长舒一口气。</p>
<p>还是由于人手紧缺（<del>流程不规范</del>），在 2020 年前的一个月内，自己又经历了一波半封闭开发，找回了在校期间极限开发 hackday 的感觉。</p>
<p>一件可圈可点的事情就是，做了一些微小的 devops 工作。因为我们作为一个中台部门，需要和多端对接，工程本身的性质较为特殊。组里几位同事一起折腾了两个月，把研发流程和效率从原始时代拉到了一个不错的水平。<del>当然，可能连老大也觉得到了不得不做的阶段，不然是不会做的</del></p>
<p>工作后我认识到成长是自己的事情。组里的同事、老大和你也只是合作关系，并不会太 care 你的成长。虽然公司会对外宣称“十分看重应届生的个人技术成长”，但是在我看来，<strong>成长一定是自己的事情，公司根本没有培养的义务，也不会付出额外成本培养你。部门的业务功能一个接着一个，需求是永远做不完的。</strong></p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>感觉在有了女朋友以后生活还是丰富了很多的，至少不再是宿舍食堂教学楼启明学院这种 X 点一线的生活了。19 年年初因为两个人都不算很忙，每逢周末也都会出去玩。毕业以后基本上开启了两人的异地生活。我在中秋和国庆回了两趟武汉，和两位优秀毕业生同学面基撸串，也和女朋友继续在武汉玩了几天。总之在毕业这一年把武汉三镇都逛了一遍，算是对得起在这个城市生活的五年吧。</p>
<p>在北京半年的体验感觉挺一般的。一方面可能是工作太忙，另一方面，在美食方面北京真的是荒漠。在家里（或者武汉，整个湖北）可以做到一周过早不重样，到了北京以后，可能就只能花 21 块钱在 X 丰包子店买「二两包子、一份炒肝、一盘芥菜」这种套餐，或者是咸的要命还难吃的老北京炸酱面。</p>
<h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>其实我一直是有继续读书的想法的，当然最终由于挂科选择了工作。挂科的直接原因是自己作死，根本原因还是在软院这个大环境之下，自己对课程和学习的懈怠（<del>都翘了？</del>）。</p>
<p>十分羡慕在校期间的学生，因为他们有大把时间可以试错，可以折腾。对于工作后的我来说，准备读书的时间和机会成本就高多了，而且随着时间推移会继续上升。</p>
<blockquote>
<p>种一棵树最好的时间是十年前，其次是现在</p>
</blockquote>
<p>无论最终情况如何，既然有读书的想法，准备工作是要提前做的。</p>
<p>19 年最后几个月时间，借着每天下班的那一点点时间把高数上册看了一遍，课后习题也动手做了做，回想起大一新入学时期微积分老师的一句话：</p>
<blockquote>
<p>我可能是你们整个大学期间讲课讲得最好的老师</p>
</blockquote>
<p>自己的英语水平其实也挺一般，词汇量不够，四六级分数还行都是靠应试技巧考的。从 19 年 10 月份到现在，考研大纲里除了零频词（过去若干年英语试卷上尚未出现过的考纲单词）没背完，基本上也都过了一遍。之前的我总是有三天打鱼两天晒网的习惯，这一次确实切身体会到坚持的作用。随着背单词的数量慢慢变多，近期在看维基和一些文档的时候，会欣喜的发现一些近期背过的单词，也算是小有成就感吧。</p>
<p>上班期间中午午休前会抽空翻翻操作系统和计算机网络的 PDF。虽然两年前都看过一遍，但再次翻阅的过程中确实有新的收获。“温故而知新”。</p>
<p>2020 年年初，自己所在的省份遭遇了一场新型冠状病毒肺炎，春节延期在家期间，刚好也有了更多时间来考虑读书深造这件事。现在已经是 2 月，留给我的时间也越来越少了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://llag9810.github.io/2020/02/02/Hello-2020-2019%E6%B5%81%E6%B0%B4%E8%B4%A6/" data-id="ck65cnif900005h6j1zpt1bp1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-自底向上看Kotlin协程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time datetime="2020-01-19T08:40:05.000Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/">自底向上看Kotlin协程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻译自 A Bottom-Up View of Kotlin Coroutines<br>原文链接：<a href="https://www.infoq.com/articles/kotlin-coroutines-bottom-up/" target="_blank" rel="noopener">https://www.infoq.com/articles/kotlin-coroutines-bottom-up/</a></p>
<h1 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h1><ul>
<li>JVM 并未提供 native 的协程支持</li>
<li>Kotlin 在编译器中通过（将函数）转换为状态机实现协程</li>
<li>Kotlin 实现协程只使用了一个保留字，剩余部分都通过 Library 实现</li>
<li>Kotlin 使用 Continuation Passing Style(CPS) 来实现</li>
<li>协程会使用调度器 (Dispatchers)，所以在 JavaFX，Android 和 Swing 中使用可能会有些许差异。</li>
</ul>
<hr>
<p>协程尽管已经不是个新鲜事物，但仍然是个引人入胜的话题。从各种文档中可以看到，协程在多年来已经被反复多次挖掘，典型的情况是需要一种轻量级的线程，或是为了解决“回调地狱”的问题。</p>
<p>近期在 JVM 平台上，协程已成为响应式编程 (Reactive Programming) 之外的另一种选择。诸如 RxJava 和 Project Reactor 等框架提供给用户一种增量处理信息的方式，同时对节流和并行提供了广泛的支持。但是你必须使用响应式流 (reactive streams) 和函数式操作 (functional operation) 重构代码，在许多场景下这是弊大于利的。</p>
<p>这就是 Android 社区内一直在寻求一种更简单的替代方案的原因。Kotlin 语言引入协程并将其作为实验功能来满足需求，同时在经过一些修订之后，Kotlin 的 1.3 版本已经将其作为正式 feature。协程已经逐渐跳出了 GUI 开发的圈子，被服务端框架（比如Spring 5）和 Arrow 等函数式编程框架采用。</p>
<hr>
<h1 id="学习协程的挑战"><a href="#学习协程的挑战" class="headerlink" title="学习协程的挑战"></a>学习协程的挑战</h1><p>不幸的是，理解协程并不容易。尽管已经有非常多来自 Kotlin 砖家的访谈，但是其中很多只是对“协程是什么”或者“如何使用协程”提供了单一的看法，很难将这些看法聚合在一块。你可能会说协程是并行编程中的 monads。</p>
<p>一部分问题在于其背后的实现。Kotlin 编译器只实现了一个 <strong>suspend</strong> 关键词，剩余部分都由协程库来处理。协程从结果上看来一个非常强大和灵活的工具，但是也有些杂乱无章。这就给新手学习造成了障碍，他们需要通过可靠的引导和严格的规范才能学好。这篇文章从自底向上的视角来看协程，希望能够以此提供一些基础。</p>
<h1 id="示例程序（服务端）"><a href="#示例程序（服务端）" class="headerlink" title="示例程序（服务端）"></a>示例程序（服务端）</h1><p>我们的应用将基于一个经典的问题，这个问题需要安全有效地多次调用 RESTful 服务。我们来玩一个《Where’s Waldo》的文字版游戏——用户需要遵循一系列名字的规则，直到最终到达“ Waldo”。</p>
<p>下面是一个使用 Http4k 编写的 RESTful 服务。Marius Eriksen 在一篇众所周知的 paper 中提出了一种函数式服务端架构，Http4k 就是这一架构的 Kotlin 实现。这一框架在许多其他语言中都有实现，包括 Scala(Http4s)和Java8(Http4j)。</p>
<p>假设有一个路由通过 Map 实现了一串名称。当传入一个名字时，我们要么返回对应的值和 200 状态码，要么返回 404 和一条错误信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> names = mapOf(</span><br><span class="line">       <span class="string">"Jane"</span> to <span class="string">"Dave"</span>,</span><br><span class="line">       <span class="string">"Dave"</span> to <span class="string">"Mary"</span>,</span><br><span class="line">       <span class="string">"Mary"</span> to <span class="string">"Pete"</span>,</span><br><span class="line">       <span class="string">"Pete"</span> to <span class="string">"Lucy"</span>,</span><br><span class="line">       <span class="string">"Lucy"</span> to <span class="string">"Waldo"</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> lookupName = &#123; request: Request -&gt;</span><br><span class="line">       <span class="keyword">val</span> name = request.path(<span class="string">"name"</span>)</span><br><span class="line">       <span class="keyword">val</span> headers = listOf(<span class="string">"Content-Type"</span> to <span class="string">"text/plain"</span>)</span><br><span class="line">       <span class="keyword">val</span> result = names[name]</span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">           Response(OK)</span><br><span class="line">               .headers(headers)</span><br><span class="line">               .body(result)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Response(NOT_FOUND)</span><br><span class="line">               .headers(headers)</span><br><span class="line">               .body(<span class="string">"No match for <span class="variable">$name</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   routes(</span><br><span class="line">       <span class="string">"/wheresWaldo"</span> bind routes(</span><br><span class="line">           <span class="string">"/&#123;name:.*&#125;"</span> bind Method.GET to lookupName</span><br><span class="line">       )</span><br><span class="line">   ).asServer(Netty(<span class="number">8080</span>))</span><br><span class="line">       .start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体上，我们想让客户端发起类似以下一连串请求：<br><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/1.jpg" alt="1"></p>
<h1 id="示例程序（客户端）"><a href="#示例程序（客户端）" class="headerlink" title="示例程序（客户端）"></a>示例程序（客户端）</h1><p>客户端应用是一个基于 JavaFX 的桌面图形界面。为了简化工作和避免一些不必要的细节，我们使用 TornadoFX，它将一些 Kotlin DSL 应用于 JavaFX 的上层。</p>
<p>以下是客户端视图的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldView</span>: <span class="type">View</span></span>(<span class="string">"Coroutines Client UI"</span>) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> finder: HttpWaldoFinder <span class="keyword">by</span> inject()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> inputText = SimpleStringProperty(<span class="string">"Jane"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> resultText = SimpleStringProperty(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> root = form &#123;</span><br><span class="line">       fieldset(<span class="string">"Lets Find Waldo"</span>) &#123;</span><br><span class="line">           field(<span class="string">"First Name:"</span>) &#123;</span><br><span class="line">               textfield().bind(inputText)</span><br><span class="line">               button(<span class="string">"Search"</span>) &#123;</span><br><span class="line">                   action &#123;</span><br><span class="line">                       println(<span class="string">"Running event handler"</span>.addThreadId())</span><br><span class="line">                       searchForWaldo()</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           field(<span class="string">"Result:"</span>) &#123;</span><br><span class="line">               label(resultText)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">searchForWaldo</span><span class="params">()</span></span> &#123;</span><br><span class="line">       GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">           println(<span class="string">"Doing Coroutines"</span>.addThreadId())</span><br><span class="line">           <span class="keyword">val</span> input = inputText.value</span><br><span class="line">           <span class="keyword">val</span> output = finder.wheresWaldo(input)</span><br><span class="line">           resultText.value = output</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们同时也会用以下辅助函数作为 String 类的扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">addThreadId</span><span class="params">()</span></span> = <span class="string">"<span class="variable">$this</span> on thread <span class="subst">$&#123;Thread.currentThread().id&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>下面是 UI 的大致样式：<br><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/2.jpg" alt="2"></p>
<p>当用户点击按钮时，会启动一个新的协程，通过一个 service 对象 <code>HttpWaldoFinder</code> 访问 RESTful 路由。</p>
<p>Kotlin 协程只在一个“协程作用域”中生存，协程作用域和一个代表其底层并发模型的调度器相关联。这个并发模型通常是一个线程池，但是也有很多其它选择。</p>
<p>有哪些调度器可用取决于运行 Kotlin 代码的环境。Main Dispatcher 通常表示 UI 库的事件处理线程，因此（在JVM上）仅在 Android，JavaFX 和 Swing 中可用。最初，Kotlin Native 根本不支持 Coroutines 多线程，但是这种情况正在改变。在服务端，你可以自己引入协程，但是越来越多的地方已经默认支持了，例如 Spring 5。</p>
<p>在开始调用 suspend 方法之前，我们必须有一个协程，一个“协程作用域 (CoroutineScope) ”和一个“调度器  (Dispatcher)”。如果是第一次调用（如上面的代码所示），我们可以通过“协程构建器”（如<code>launch</code>和<code>async</code>）来启动一个协程。</p>
<p>调用协程构建函数或“<code>withContext</code>”之类的作用域函数，都始终会创建一个新的协程作用域。在作用域内，协程所执行的任务由 Job 实例组成的层级结构表示。</p>
<p>有一些有趣的特性，即：</p>
<ul>
<li>每一个 Job 会先等待自己作用域中的所有协程完成，然后再完成自身。</li>
<li>取消一个 Job 导致其所有子 Job 被取消。</li>
<li>子 Job 的失败或取消会传播到父 Job</li>
</ul>
<p>这样设计旨在避免并发编程中的常见问题，例如在不终止子任务的情况下把父任务杀死了。</p>
<h1 id="访问-REST-路由的服务"><a href="#访问-REST-路由的服务" class="headerlink" title="访问 REST 路由的服务"></a>访问 REST 路由的服务</h1><p>这是我们的<code>HttpWaldoFinder</code>服务的完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpWaldoFinder</span> : <span class="type">Controller</span></span>(), WaldoFinder &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">wheresWaldo</span><span class="params">(starterName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">val</span> firstName = fetchNewName(starterName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$firstName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> secondName = fetchNewName(firstName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$secondName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> thirdName = fetchNewName(secondName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$thirdName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> fourthName = fetchNewName(thirdName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$fourthName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> fetchNewName(fourthName)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNewName</span><span class="params">(inputName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">val</span> url = URI(<span class="string">"http://localhost:8080/wheresWaldo/<span class="variable">$inputName</span>"</span>)</span><br><span class="line">       <span class="keyword">val</span> client = HttpClient.newBuilder().build()</span><br><span class="line">       <span class="keyword">val</span> handler = HttpResponse.BodyHandlers.ofString()</span><br><span class="line">       <span class="keyword">val</span> request = HttpRequest.newBuilder().uri(url).build()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> withContext&lt;String&gt;(Dispatchers.IO) &#123;</span><br><span class="line">           println(<span class="string">"Sending HTTP Request for <span class="variable">$inputName</span>"</span>.addThreadId())</span><br><span class="line">           client</span><br><span class="line">               .send(request, handler)</span><br><span class="line">               .body()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchNewName</code>函数接受一个已知的人名，并且通过请求路由拿到和它关联的名字。这是通过 HttpClient 完成的，HttpClient 自从 Java 11 之后成为了标准。实际的 HTTP GET 请求运行在一个使用 IO Dispatcher 的新协程之中。其中 IO Dispatcher 通常意味着一个线程池，其为长期运行的任务（如网络调用）做了优化。</p>
<p><code>wheresWaldo</code>函数调用请求五次来寻找”Waldo”。因为我们随后会反编译生成的字节码，所以我们实现尽可能的简单。值得注意的是，每一次调用<code>fetchNewName</code>，当子协程运行过程中，会导致当前协程被挂起。在这个特定例子里，父协程运行于 Main Dispatcher，子协程运行于 IO Dispatcher。所以，当子协程在执行 HTTP 请求时，UI 事件处理线程会被释放开来，以处理其它用户与视图的交互。如下图所示：</p>
<p><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/3.jpg" alt="3"></p>
<p>当我们调用一个 suspend 函数时，Intellij 会作出提示，同时转换协程之间的控制权。注意到，如果我们在调用时不切换调度器，则并不一定会导致创建新的协程。当一个 suspend 函数调用另一个 suspend 函数时，可以在同一协程中继续执行，实际上，如果我们想要将两次调用停留在同一线程上，这恰恰是我们期望的行为。</p>
<p><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/4.jpg" alt="4"></p>
<p>当我们执行客户端时，这是控制台的输出：</p>
<p><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/5.jpg" alt="5"></p>
<p>可以看到，在这一特定情况下，Main Dispatcher 在线程17上运行，而 IO Dispatcher 在包含线程 24 和 26 的线程池上运行。</p>
<h1 id="开始探索"><a href="#开始探索" class="headerlink" title="开始探索"></a>开始探索</h1><p>使用 IntelliJ 自带的字节码反汇编工具，我们可以一探究竟。当然我们还可以使用 JDK 随附的标准“javap”工具。</p>
<p><img src="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/6.jpg" alt="6"></p>
<p>我们可以看到 <code>HttpWaldoFinder</code> 的方法签名变了。它额外多了一个参数接受 continuation 对象，同时返回值变成了一个 Object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpWaldoFinder</span> <span class="keyword">extends</span> <span class="title">Controller</span> <span class="keyword">implements</span> <span class="title">WaldoFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">wheresWaldo</span><span class="params">(String a, Continuation b)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">final</span> synthetic Object <span class="title">fetchNewName</span><span class="params">(String a, Continuation b)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>接下来我们深入研究添加到这些方法中的代码，并解释“continuation”是什么，以及被修改过的函数返回值到底是什么。</p>
<h1 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation Passing Style (CPS)"></a>Continuation Passing Style (CPS)</h1><p>按照 Kotlin 标准化进程中的协程提案记载，协程的实现是基于 Continuation Passing Style。而 continuation 对象用于存储函数挂起时所必须的状态。</p>
<p>实际上，suspend 函数中的每个局部变量都会成为 continuation 对象中的一个属性。同时如果函数是某个类的方法，还会为该函数的参数和当前对象的引用创建 continuation 中的属性。假设一个挂起方法有 4 个参数和 5 个局部变量，那么生成的 continuation 对象中有至少 10 个字段。</p>
<p>在 <code>HttpWaldoFinder</code> 类的 <code>wheresWaldo</code> 方法中，有一个参数，4 个局部变量。所以 continuation 对象当中应当有 6 个字段。若我们将 kotlin 编译器生成的字节码反编译为 Java 代码，可以发现的确如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$continuation = <span class="keyword">new</span> ContinuationImpl($completion) &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">int</span> label;</span><br><span class="line">  Object L$<span class="number">0</span>;</span><br><span class="line">  Object L$<span class="number">1</span>;</span><br><span class="line">  Object L$<span class="number">2</span>;</span><br><span class="line">  Object L$<span class="number">3</span>;</span><br><span class="line">  Object L$<span class="number">4</span>;</span><br><span class="line">  Object L$<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.result = $result;</span><br><span class="line">     <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">     <span class="keyword">return</span> HttpWaldoFinder.<span class="keyword">this</span>.wheresWaldo((String)<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于所有成员变量都是 Object 类型，因此它们的作用并不是很明显。但是随着我们进一步探索，我们将看到：</p>
<ul>
<li><code>L$0</code>保存对<code>HttpWaldoFinder</code>实例的引用。始终如此。</li>
<li><code>L$1</code>保存<code>starterName</code>参数的值。始终如此。</li>
<li><code>L$2</code>至<code>L$5</code>保留局部变量的值。这些将在代码执行时逐步填充。<code>L$2</code>将保留<code>firstName</code>的值，依此类推。</li>
</ul>
<p>我们还有其他字段用于最终结果，和一个有趣的整数，称为“label”。</p>
<h1 id="挂起还是不挂起—这是一个值得考虑的问题"><a href="#挂起还是不挂起—这是一个值得考虑的问题" class="headerlink" title="挂起还是不挂起—这是一个值得考虑的问题"></a>挂起还是不挂起—这是一个值得考虑的问题</h1><p>我们查看编译器生成的代码时，有一点要注意：代码必须处理两种情况。每当一个 suspend 函数调用另一个时，它有可能挂起当前的协程（随后另一个函数可以运行到相同的协程），也有可能继续执行当前协程。</p>
<p>假设有一个 suspend 函数从数据存储中读取一个值，大概率它会在 I/O 时被挂起。但是它也有可能有缓存，接下来直接同步返回缓存结果。Kotlin 编译器生成的代码必须允许每一种情况。</p>
<p>Kotlin 编译器调整了每个 suspend 函数的返回值类型，因此其既可以返回真正的结果，也可以返回一个特殊值 <code>COROUTINE_SUSPENDED</code>。如果是后者则代表当前的协程挂起了。这就是 suspend 函数的返回值从原有的结果类型变成了 Object 的原因。</p>
<p>在我们的例子 <code>wheresWaldo</code> 中，它反复的调用了 <code>fetchNewName</code>。理论上每一次调用有可能会挂起，也有可能不挂起当前的协程。作为编写 <code>fetchNewName</code> 函数的程序员，我们一定很清楚这里会发生挂起。但是要想使生成的代码能够跑通，我们必须清楚它需要处理所有的情况。</p>
<h1 id="巨大的-switch-语句和标签"><a href="#巨大的-switch-语句和标签" class="headerlink" title="巨大的 switch 语句和标签"></a>巨大的 switch 语句和标签</h1><p>我们进一步看反编译的代码，可以发现一个 switch 表达式和其中很多嵌套的标签。这其实是一个状态机的实现，用于控制 <code>wheresWaldo</code> 方法中的不同挂起点。这是其整体结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing one: the generated switch statement and labels</span></span><br><span class="line">String firstName;</span><br><span class="line">String secondName;</span><br><span class="line">String thirdName;</span><br><span class="line">String fourthName;</span><br><span class="line">Object var11;</span><br><span class="line">Object var10000;</span><br><span class="line">label48: &#123;</span><br><span class="line">  label47: &#123;</span><br><span class="line">     label46: &#123;</span><br><span class="line">        Object $result = $continuation.result;</span><br><span class="line">        var11 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        <span class="keyword">switch</span>($continuation.label) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="comment">// code omitted</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"call to 'resume' before 'invoke' with coroutine"</span>);</span><br><span class="line">        &#125; <span class="comment">// end of switch</span></span><br><span class="line">        <span class="comment">// code omitted</span></span><br><span class="line">    &#125; <span class="comment">// end of label 46</span></span><br><span class="line">    <span class="comment">// code omitted</span></span><br><span class="line">  &#125; <span class="comment">// end of label 47</span></span><br><span class="line">  <span class="comment">// code omitted</span></span><br><span class="line">&#125; <span class="comment">// end of label 48</span></span><br><span class="line"><span class="comment">// code omitted</span></span><br></pre></td></tr></table></figure>

<p>现在可以看出 contiuation 中 <code>label</code> 字段的目的了。当完成了 <code>wheresWaldo</code> 的不同阶段时，我们会修改 <code>label</code> 的值。嵌套的语句块包含了原始 kotlin 代码挂起点之间的代码。<code>label</code> 值允许代码是可重入的，并且可以跳到上一次挂起的地方(适宜的case 语句)，从 continuation 对象中取回信息，然后 break 掉对应的代码块。</p>
<p>然而，如果所有的挂起点都最终没有挂起的话，整个代码块将同步执行。在生成的代码中我们经常看到以下片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing two - deciding if the current coroutine should suspend</span></span><br><span class="line"><span class="keyword">if</span> (var10000 == var11) &#123;</span><br><span class="line">  <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的 <code>var11</code> 已经被赋值为 <code>CONTINUATION_SUSPENDED</code>，同时 <code>var10000</code> 持有另一个 suspend 函数的返回值。所以，当发生挂起操作时，上述代码返回（后续会重入）。如果没有发生挂起，代码会通过 break 一个合适的 label 继续执行下一个部分。</p>
<p>再次提示，生成的编译代码并不能假设所有的调用都会被挂起，或者所有的调用都会继续执行。它必须处理每一种可能。</p>
<h1 id="跟踪执行过程"><a href="#跟踪执行过程" class="headerlink" title="跟踪执行过程"></a>跟踪执行过程</h1><p>当我们开始执行时，continuation 中的 label 初始值是 0。以下是对应的 switch 分支：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing three - the first branch of the switch</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  ResultKt.throwOnFailure($result);</span><br><span class="line">  $continuation.L$<span class="number">0</span> = <span class="keyword">this</span>;</span><br><span class="line">  $continuation.L$<span class="number">1</span> = starterName;</span><br><span class="line">  $continuation.label = <span class="number">1</span>;</span><br><span class="line">  var10000 = <span class="keyword">this</span>.fetchNewName(starterName, $continuation);</span><br><span class="line">  <span class="keyword">if</span> (var10000 == var11) &#123;</span><br><span class="line">     <span class="keyword">return</span> var11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>我们将当前类的实例（this 指针）和参数存入 continuation 对象，然后将 continuation 作为参数传入 <code>fetchNewName</code>。我们之前已经讨论过，<code>fetchNewName</code> 会返回真正的结果或者一个 <code>CONTINUATION_SUSPENDED</code> 值。</p>
<p>如果协程被挂起，那么我们会从函数中返回，并且下一次恢复的时候会跳到 <code>case 1</code> 的分支。如果我们继续执行协程，那么我们会从 switch 语句中跳出，执行以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing four - calling ‘fetchNewName’ for the second time</span></span><br><span class="line">firstName = (String)var10000;</span><br><span class="line">secondName = UtilsKt.addThreadId(<span class="string">"Found "</span> + firstName + <span class="string">" name"</span>);</span><br><span class="line"><span class="keyword">boolean</span> var13 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(secondName);</span><br><span class="line">$continuation.L$<span class="number">0</span> = <span class="keyword">this</span>;</span><br><span class="line">$continuation.L$<span class="number">1</span> = starterName;</span><br><span class="line">$continuation.L$<span class="number">2</span> = firstName;</span><br><span class="line">$continuation.label = <span class="number">2</span>;</span><br><span class="line">var10000 = <span class="keyword">this</span>.fetchNewName(firstName, $continuation);</span><br><span class="line"><span class="keyword">if</span> (var10000 == var11) &#123;</span><br><span class="line">  <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为已知 <code>var10000</code> 包含了我们想要的返回值，我们可以转换到正确到类型并且保存到局部变量 <code>firstName</code> 中。生成的代码接下来用 <code>secondName</code> 存放增加了线程 ID 的值，然后接下来被输出。</p>
<p>continuation 中的值被更新，添加了我们从服务端取回的值。注意到 label 的值现在是 2，我们接下来第三次执行<code>fetchNewName</code></p>
<h1 id="第三次执行—不挂起"><a href="#第三次执行—不挂起" class="headerlink" title="第三次执行—不挂起"></a>第三次执行—不挂起</h1><p>我们需要根据 <code>fetchNewName</code> 的返回值再次做选择。如果返回值是 <code>CONTINUATION_SUSPENDED</code> 我们直接返回，下一次调用时直接进入 <code>case 2</code> 的分支。</p>
<p>如果我们在当前协程继续执行，那么接下来的代码块会被执行。如你所见，这和上面出现的代码是相同的，除了我们向 continuation 中存放了更多的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing four - calling ‘fetchNewName’ for the third time</span></span><br><span class="line">secondName = (String)var10000;</span><br><span class="line">thirdName = UtilsKt.addThreadId(<span class="string">"Found "</span> + secondName + <span class="string">" name"</span>);</span><br><span class="line"><span class="keyword">boolean</span> var14 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(thirdName);</span><br><span class="line">$continuation.L$<span class="number">0</span> = <span class="keyword">this</span>;</span><br><span class="line">$continuation.L$<span class="number">1</span> = starterName;</span><br><span class="line">$continuation.L$<span class="number">2</span> = firstName;</span><br><span class="line">$continuation.L$<span class="number">3</span> = secondName;</span><br><span class="line">$continuation.label = <span class="number">3</span>;</span><br><span class="line">var10000 = <span class="keyword">this</span>.fetchNewName(secondName, (Continuation)$continuation);</span><br><span class="line"><span class="keyword">if</span> (var10000 == var11) &#123;</span><br><span class="line">  <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果后续的代码不挂起，那么剩下的部分会一直按这个模式执行下去直到函数结束。</p>
<h1 id="第三次执行—挂起"><a href="#第三次执行—挂起" class="headerlink" title="第三次执行—挂起"></a>第三次执行—挂起</h1><p>另一种情况是，如果协程被挂起，那么我们会执行以下的 case 代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing five - the third branch of the switch</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  firstName = (String)$continuation.L$<span class="number">2</span>;</span><br><span class="line">  starterName = (String)$continuation.L$<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span> = (HttpWaldoFinder)$continuation.L$<span class="number">0</span>;</span><br><span class="line">  ResultKt.throwOnFailure($result);</span><br><span class="line">  var10000 = $result;</span><br><span class="line">  <span class="keyword">break</span> label46;</span><br></pre></td></tr></table></figure>

<p>我们从 continuation 中提取值，保存到函数的局部变量中。一个带有 label 的 break 会将代码跳转到上一章节代码注释中的 listing four。因此，无论是否挂起，最终我们将在同一处结束。</p>
<h1 id="汇总执行过程"><a href="#汇总执行过程" class="headerlink" title="汇总执行过程"></a>汇总执行过程</h1><p>重温我们梳理的代码结构，我们可以从一个很高的角度来描述每个阶段到底做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listing six - the generated switch statement and labels in depth</span></span><br><span class="line">String firstName;</span><br><span class="line">String secondName;</span><br><span class="line">String thirdName;</span><br><span class="line">String fourthName;</span><br><span class="line">Object var11;</span><br><span class="line">Object var10000;</span><br><span class="line">label48: &#123;</span><br><span class="line">  label47: &#123;</span><br><span class="line">     label46: &#123;</span><br><span class="line">        Object $result = $continuation.result;</span><br><span class="line">        var11 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        <span class="keyword">switch</span>($continuation.label) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// set label to 1 and make the first call to ‘fetchNewName’</span></span><br><span class="line">            <span class="comment">// if suspending return, otherwise break from the switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// extract the parameter from the continuation</span></span><br><span class="line">            <span class="comment">// break from the switch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">// extract the parameter and first result from the continuation</span></span><br><span class="line">            <span class="comment">// break to outside ‘label46’</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">// extract the parameter, first and second results from the</span></span><br><span class="line">            <span class="comment">//   continuation</span></span><br><span class="line">            <span class="comment">// break to outside ‘label47’</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="comment">// extract the parameter, first, second and third results from</span></span><br><span class="line">            <span class="comment">//   the continuation</span></span><br><span class="line">            <span class="comment">// break to outside ‘label48’</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="comment">// extract the parameter, first, second, third and fourth</span></span><br><span class="line">            <span class="comment">//   results from the continuation</span></span><br><span class="line">            <span class="comment">// return the final result</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"call to 'resume' before 'invoke' with coroutine"</span>);</span><br><span class="line">        &#125; <span class="comment">// end of switch</span></span><br><span class="line">        <span class="comment">// store the parameter and first result in the continuation</span></span><br><span class="line">        <span class="comment">// set the label to 2 and make the second call to ‘fetchNewName’</span></span><br><span class="line">        <span class="comment">// if suspending return, otherwise proceed</span></span><br><span class="line">    &#125; <span class="comment">// end of label 46</span></span><br><span class="line">        <span class="comment">// store the parameter, first and second results in the</span></span><br><span class="line">        <span class="comment">//   continuation</span></span><br><span class="line">        <span class="comment">// set the label to 3 and make the third call to ‘fetchNewName’</span></span><br><span class="line">        <span class="comment">// if suspending return, otherwise proceed</span></span><br><span class="line">  &#125; <span class="comment">// end of label 47</span></span><br><span class="line">        <span class="comment">// store the parameter, first, second and third results in the   </span></span><br><span class="line">        <span class="comment">//   continuation</span></span><br><span class="line">        <span class="comment">// set the label to 4 and make the fourth call to ‘fetchNewName’</span></span><br><span class="line">        <span class="comment">// if suspending return, otherwise proceed</span></span><br><span class="line">&#125; <span class="comment">// end of label 48</span></span><br><span class="line"><span class="comment">// store the parameter, first, second, third and fourth results in the continuation</span></span><br><span class="line"><span class="comment">// set the label to 5 and make the fifth call to ‘fetchNewName’</span></span><br><span class="line"><span class="comment">// return either the final result or COROUTINE_SUSPENDED</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些代码并不容易理解。我们正在研究从 Kotlin 编译器生成的字节码反汇编的 Java 代码。此代码生成器的输出旨在提高效率和简约性，而非清晰。</p>
<p>但是，我们可以得出一些有用的结论：</p>
<ul>
<li><strong>并没有黑魔法</strong>。当开发人员首次了解协程时，很容易假设有一些特殊的“魔法”将所有东西捆绑在一起。如我们所见，生成的代码仅使用了面向过程编程的基本代码块，例如条件和标记的中断。</li>
<li><strong>协程的实现是基于 continuation 的</strong>。如最初 KEEP 提案中所述，通过在对象内缓存函数的状态来挂起和恢复函数。因此，对于每个挂起函数，编译器将创建一个具有 N 个字段的 continuation 类型，其中 N 是参数数量加上成员变量的字段数量加 3。最后的 3 分别保存当前对象（this），最终结果（返回值）和索引值（label）。</li>
<li><strong>执行过程始终遵循一套标准模式</strong>。如果要从挂起中恢复，则可以使用 continuation 对象的 <code>label</code> 字段跳转到 switch 语句的适当分支。在这个分支中，我们取得 continuation 对象执行到当前的数据，然后使用 labelled break 跳转到下一段代码，如果没有发生挂起，这段代码将直接执行。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://llag9810.github.io/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/" data-id="ck65cnifg00025h6j57lj2vts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/hello-world/" class="article-date">
  <time datetime="2020-01-19T08:22:26.013Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://llag9810.github.io/2020/01/19/hello-world/" data-id="ck65cnife00015h6j6yi46uai" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/02/Hello-2020-2019%E6%B5%81%E6%B0%B4%E8%B4%A6/">Hello 2020 &amp; 2019 流水账</a>
          </li>
        
          <li>
            <a href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/">自底向上看Kotlin协程</a>
          </li>
        
          <li>
            <a href="/2020/01/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hexo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>