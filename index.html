<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://llag9810.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://llag9810.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-自底向上看Kotlin协程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time datetime="2020-01-19T08:40:05.000Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/">自底向上看Kotlin协程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h1><ul>
<li>JVM 并未提供 native 的协程支持</li>
<li>Kotlin 在编译器中通过（将函数）转换为状态机实现协程</li>
<li>Kotlin 实现协程只使用了一个保留字，剩余部分都通过 Library 实现</li>
<li>Kotlin 使用 Continuation Passing Style(CPS) 来实现</li>
<li>协程会使用调度器 (Dispatchers)，所以在 JavaFX，Android 和 Swing 中使用可能会有些许差异。</li>
</ul>
<hr>
<p>协程尽管已经不是个新鲜事物，但仍然是个引人入胜的话题。从各种文档中可以看到，协程在多年来已经被反复多次挖掘，典型的情况是需要一种轻量级的线程，或是为了解决“回调地狱”的问题。</p>
<p>近期在 JVM 平台上，协程已成为响应式编程 (Reactive Programming) 之外的另一种选择。诸如 RxJava 和 Project Reactor 等框架提供给用户一种增量处理信息的方式，同时对节流和并行提供了广泛的支持。但是你必须使用响应式流 (reactive streams) 和函数式操作 (functional operation) 重构代码，在许多场景下这是弊大于利的。</p>
<p>这就是 Android 社区内一直在寻求一种更简单的替代方案的原因。Kotlin 语言引入协程并将其作为实验功能来满足需求，同时在经过一些修订之后，Kotlin 的 1.3 版本已经将其作为正式 feature。协程已经逐渐跳出了 GUI 开发的圈子，被服务端框架（比如Spring 5）和 Arrow 等函数式编程框架采用。</p>
<hr>
<h1 id="理解协程的挑战"><a href="#理解协程的挑战" class="headerlink" title="理解协程的挑战"></a>理解协程的挑战</h1><p>不幸的是，理解协程并不容易。尽管已经有非常多来自 Kotlin 砖家的访谈，但是其中很多只是对“协程是什么”或者“如何使用协程”提供了单一的看法，很难将这些看法聚合在一块。你可能会说协程是并行编程中的 monads。</p>
<p>一部分问题在于其背后的实现。Kotlin 编译器只实现了一个 <strong>suspend</strong> 关键词，剩余部分都由协程库来处理。协程从结果上看来一个非常强大和灵活的工具，但是也有些杂乱无章。这就给新手学习造成了障碍，他们需要通过可靠的引导和严格的规范才能学好。这篇文章从自底向上的视角来看协程，希望能够以此提供一些基础。</p>
<h1 id="示例程序（服务端）"><a href="#示例程序（服务端）" class="headerlink" title="示例程序（服务端）"></a>示例程序（服务端）</h1><p>我们的应用将基于一个经典的问题，这个问题需要安全有效地多次调用 RESTful 服务。我们来玩一个《Where’s Waldo》的文字版游戏——用户需要遵循一系列名字的规则，直到最终到达“ Waldo”。</p>
<p>下面是一个使用 Http4k 编写的 RESTful 服务。Marius Eriksen 在一篇众所周知的 paper 中提出了一种函数式服务端架构，Http4k 就是这一架构的 Kotlin 实现。这一框架在许多其他语言中都有实现，包括 Scala(Http4s)和Java8(Http4j)。</p>
<p>假设有一个路由通过 Map 实现了一串名称。当传入一个名字时，我们要么返回对应的值和 200 状态码，要么返回 404 和一条错误信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> names = mapOf(</span><br><span class="line">       <span class="string">"Jane"</span> to <span class="string">"Dave"</span>,</span><br><span class="line">       <span class="string">"Dave"</span> to <span class="string">"Mary"</span>,</span><br><span class="line">       <span class="string">"Mary"</span> to <span class="string">"Pete"</span>,</span><br><span class="line">       <span class="string">"Pete"</span> to <span class="string">"Lucy"</span>,</span><br><span class="line">       <span class="string">"Lucy"</span> to <span class="string">"Waldo"</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> lookupName = &#123; request: Request -&gt;</span><br><span class="line">       <span class="keyword">val</span> name = request.path(<span class="string">"name"</span>)</span><br><span class="line">       <span class="keyword">val</span> headers = listOf(<span class="string">"Content-Type"</span> to <span class="string">"text/plain"</span>)</span><br><span class="line">       <span class="keyword">val</span> result = names[name]</span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">           Response(OK)</span><br><span class="line">               .headers(headers)</span><br><span class="line">               .body(result)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Response(NOT_FOUND)</span><br><span class="line">               .headers(headers)</span><br><span class="line">               .body(<span class="string">"No match for <span class="variable">$name</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   routes(</span><br><span class="line">       <span class="string">"/wheresWaldo"</span> bind routes(</span><br><span class="line">           <span class="string">"/&#123;name:.*&#125;"</span> bind Method.GET to lookupName</span><br><span class="line">       )</span><br><span class="line">   ).asServer(Netty(<span class="number">8080</span>))</span><br><span class="line">       .start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体上，我们想让客户端发起类似以下一连串请求：<br><img src="/.io//1.jpg" alt="1"></p>
<h1 id="示例程序（客户端）"><a href="#示例程序（客户端）" class="headerlink" title="示例程序（客户端）"></a>示例程序（客户端）</h1><p>客户端应用是一个基于 JavaFX 的桌面图形界面。为了简化工作和避免一些不必要的细节，我们使用 TornadoFX，它将一些 Kotlin DSL 应用于 JavaFX 的上层。</p>
<p>以下是客户端视图的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldView</span>: <span class="type">View</span></span>(<span class="string">"Coroutines Client UI"</span>) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> finder: HttpWaldoFinder <span class="keyword">by</span> inject()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> inputText = SimpleStringProperty(<span class="string">"Jane"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> resultText = SimpleStringProperty(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> root = form &#123;</span><br><span class="line">       fieldset(<span class="string">"Lets Find Waldo"</span>) &#123;</span><br><span class="line">           field(<span class="string">"First Name:"</span>) &#123;</span><br><span class="line">               textfield().bind(inputText)</span><br><span class="line">               button(<span class="string">"Search"</span>) &#123;</span><br><span class="line">                   action &#123;</span><br><span class="line">                       println(<span class="string">"Running event handler"</span>.addThreadId())</span><br><span class="line">                       searchForWaldo()</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           field(<span class="string">"Result:"</span>) &#123;</span><br><span class="line">               label(resultText)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">searchForWaldo</span><span class="params">()</span></span> &#123;</span><br><span class="line">       GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">           println(<span class="string">"Doing Coroutines"</span>.addThreadId())</span><br><span class="line">           <span class="keyword">val</span> input = inputText.value</span><br><span class="line">           <span class="keyword">val</span> output = finder.wheresWaldo(input)</span><br><span class="line">           resultText.value = output</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们同时也会用以下辅助函数作为 String 类的扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">addThreadId</span><span class="params">()</span></span> = <span class="string">"<span class="variable">$this</span> on thread <span class="subst">$&#123;Thread.currentThread().id&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>下面是 UI 的大致样式：<br><img src="/.io//2.jpg" alt="2"></p>
<p>当用户点击按钮时，会启动一个新的协程，通过一个 service 对象 <code>HttpWaldoFinder</code> 访问 RESTful 路由。</p>
<p>Kotlin 协程只在一个“协程作用域”中生存，协程作用域和一个代表其底层并发模型的调度器相关联。这个并发模型通常是一个线程池，但是也有很多其它选择。</p>
<p>有哪些调度器可用取决于运行 Kotlin 代码的环境。Main Dispatcher 通常表示 UI 库的事件处理线程，因此（在JVM上）仅在 Android，JavaFX 和 Swing 中可用。最初，Kotlin Native 根本不支持 Coroutines 多线程，但是这种情况正在改变。在服务端，你可以自己引入协程，但是越来越多的地方已经默认支持了，例如 Spring 5。</p>
<p>在开始调用 suspend 方法之前，我们必须有一个协程，一个“协程作用域 (CoroutineScope) ”和一个“调度器  (Dispatcher)”。如果是第一次调用（如上面的代码所示），我们可以通过“协程构建器”（如<code>launch</code>和<code>async</code>）来启动一个协程。</p>
<p>调用协程构建函数或“<code>withContext</code>”之类的作用域函数，都始终会创建一个新的协程作用域。在作用域内，协程所执行的任务由 Job 实例组成的层级结构表示。</p>
<p>有一些有趣的特性，即：</p>
<ul>
<li>每一个 Job 会先等待自己作用域中的所有协程完成，然后再完成自身。</li>
<li>取消一个 Job 导致其所有子 Job 被取消。</li>
<li>子 Job 的失败或取消会传播到父 Job</li>
</ul>
<p>这样设计旨在避免并发编程中的常见问题，例如在不终止子任务的情况下把父任务杀死了。</p>
<h1 id="访问-REST-路由的服务"><a href="#访问-REST-路由的服务" class="headerlink" title="访问 REST 路由的服务"></a>访问 REST 路由的服务</h1><p>这是我们的<code>HttpWaldoFinder</code>服务的完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpWaldoFinder</span> : <span class="type">Controller</span></span>(), WaldoFinder &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">wheresWaldo</span><span class="params">(starterName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">val</span> firstName = fetchNewName(starterName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$firstName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> secondName = fetchNewName(firstName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$secondName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> thirdName = fetchNewName(secondName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$thirdName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> fourthName = fetchNewName(thirdName)</span><br><span class="line">       println(<span class="string">"Found <span class="variable">$fourthName</span> name"</span>.addThreadId())</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> fetchNewName(fourthName)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNewName</span><span class="params">(inputName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">val</span> url = URI(<span class="string">"http://localhost:8080/wheresWaldo/<span class="variable">$inputName</span>"</span>)</span><br><span class="line">       <span class="keyword">val</span> client = HttpClient.newBuilder().build()</span><br><span class="line">       <span class="keyword">val</span> handler = HttpResponse.BodyHandlers.ofString()</span><br><span class="line">       <span class="keyword">val</span> request = HttpRequest.newBuilder().uri(url).build()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> withContext&lt;String&gt;(Dispatchers.IO) &#123;</span><br><span class="line">           println(<span class="string">"Sending HTTP Request for <span class="variable">$inputName</span>"</span>.addThreadId())</span><br><span class="line">           client</span><br><span class="line">               .send(request, handler)</span><br><span class="line">               .body()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchNewName</code>函数接受一个已知的人名，并且通过请求路由拿到和它关联的名字。这是通过 HttpClient 完成的，HttpClient 自从 Java 11 之后成为了标准。实际的 HTTP GET 请求运行在一个使用 IO Dispatcher 的新协程之中。其中 IO Dispatcher 通常意味着一个线程池，其为长期运行的任务（如网络调用）做了优化。</p>
<p><code>wheresWaldo</code>函数调用请求五次来寻找”Waldo”。因为我们随后会反编译生成的字节码，所以我们实现尽可能的简单。值得注意的是，每一次调用<code>fetchNewName</code>，当子协程运行过程中，会导致当前协程被挂起。在这个特定例子里，父协程运行于 Main Dispatcher，子协程运行于 IO Dispatcher。所以，当子协程在执行 HTTP 请求时，UI 事件处理线程会被释放开来，以处理其它用户与视图的交互。如下图所示：</p>
<p><img src="/.io//3.jpg" alt="3"></p>
<p>当我们调用一个 suspend 函数时，Intellij 会作出提示，同时转换协程之间的控制权。注意到，如果我们在调用时不切换调度器，则并不一定会导致创建新的协程。当一个 suspend 函数调用另一个 suspend 函数时，可以在同一协程中继续执行，实际上，如果我们想要将两次调用停留在同一线程上，这恰恰是我们期望的行为。</p>
<p><img src="/.io//4.jpg" alt="4"></p>
<p>当我们执行客户端时，这是控制台的输出：</p>
<p><img src="/.io//5.jpg" alt="5"></p>
<p>可以看到，在这一特定情况下，Main Dispatcher 在线程17上运行，而 IO Dispatcher 在包含线程 24 和 26 的线程池上运行。</p>
<h1 id="开始探索"><a href="#开始探索" class="headerlink" title="开始探索"></a>开始探索</h1><p>使用 IntelliJ 自带的字节码反汇编工具，我们可以一探究竟。当然我们还可以使用 JDK 随附的标准“javap”工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://llag9810.github.io/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/" data-id="ck5ks5tki0001aks6azgo7nxu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/hello-world/" class="article-date">
  <time datetime="2020-01-19T08:22:26.013Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://llag9810.github.io/2020/01/19/hello-world/" data-id="ck5ks5tkb0000aks6cjxda167" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/19/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9C%8BKotlin%E5%8D%8F%E7%A8%8B/">自底向上看Kotlin协程</a>
          </li>
        
          <li>
            <a href="/2020/01/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hexo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>